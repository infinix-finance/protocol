{
  "address": "0xD2aa12b3E893990B076F0eAB5afa3CD444FC89c8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_amm",
          "type": "address"
        }
      ],
      "name": "getAmmStates",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "quoteAssetReserve",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "baseAssetReserve",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tradeLimitRatio",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fundingPeriod",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "quoteAssetSymbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "baseAssetSymbol",
              "type": "string"
            },
            {
              "internalType": "bytes32",
              "name": "priceFeedKey",
              "type": "bytes32"
            },
            {
              "internalType": "address",
              "name": "priceFeed",
              "type": "address"
            }
          ],
          "internalType": "struct AmmReader.AmmStates",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf04b28d9c47dea8b4eec74c4c26af82a9fdfb9f90ca32b8a2af5d4819acebbf5",
  "receipt": {
    "to": null,
    "from": "0xa6D47c4Ca52df5aab11Cf90247E6e12071210625",
    "contractAddress": "0xD2aa12b3E893990B076F0eAB5afa3CD444FC89c8",
    "transactionIndex": 1,
    "gasUsed": "516832",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x718b91bae1db6ca468ea0a0c27fc2c549594b656a2be701b83e60368517d4330",
    "transactionHash": "0xf04b28d9c47dea8b4eec74c4c26af82a9fdfb9f90ca32b8a2af5d4819acebbf5",
    "logs": [],
    "blockNumber": 10359052,
    "cumulativeGasUsed": "545779",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "4c49f922d9cb7c7ed60ad782db69f561",
  "metadata": "{\"compiler\":{\"version\":\"0.6.9+commit.3e3065ac\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_amm\",\"type\":\"address\"}],\"name\":\"getAmmStates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quoteAssetReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAssetReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradeLimitRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"quoteAssetSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseAssetSymbol\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"priceFeedKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"}],\"internalType\":\"struct AmmReader.AmmStates\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"contracts/AmmReader.sol\":\"AmmReader\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\":{\"content\":\"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xe81686511d62f18b2d9c693c2c94c0a789c690de63aa90e15451ebf65c5bfd3e\"},\"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\":{\"content\":\"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\",\"keccak256\":\"0x9bfec92e36234ecc99b5d37230acb6cd1f99560233753162204104a4897e8721\"},\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x04d34b3cd5677bea25f8dfceb6dec0eaa071d4d4b789a43f13fe0c415ba4c296\"},\"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Multiplies two signed integers, reverts on overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two signed integers, reverts on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two signed integers, reverts on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xfadc24a31d75d6b3f955190cffe13bbe6e24a274c12b2b60e8c4004131487ce8\"},\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x6cc1cb934a3ac2137a7dcaed018af9e235392236ceecfd3687259702b9c767ad\"},\"contracts/Amm.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\npragma experimental ABIEncoderV2;\\n\\nimport { BlockContext } from \\\"./utils/BlockContext.sol\\\";\\nimport { IPriceFeed } from \\\"./interface/IPriceFeed.sol\\\";\\nimport { SafeMath } from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Decimal } from \\\"./utils/Decimal.sol\\\";\\nimport { SignedDecimal } from \\\"./utils/SignedDecimal.sol\\\";\\nimport { MixedDecimal } from \\\"./utils/MixedDecimal.sol\\\";\\nimport { IfnxFiOwnableUpgrade } from \\\"./utils/IfnxFiOwnableUpgrade.sol\\\";\\nimport { IAmm } from \\\"./interface/IAmm.sol\\\";\\n\\ncontract Amm is IAmm, IfnxFiOwnableUpgrade, BlockContext {\\n    using SafeMath for uint256;\\n    using Decimal for Decimal.decimal;\\n    using SignedDecimal for SignedDecimal.signedDecimal;\\n    using MixedDecimal for SignedDecimal.signedDecimal;\\n\\n    //\\n    // CONSTANT\\n    //\\n    // because position decimal rounding error,\\n    // if the position size is less than IGNORABLE_DIGIT_FOR_SHUTDOWN, it's equal size is 0\\n    uint256 private constant IGNORABLE_DIGIT_FOR_SHUTDOWN = 100;\\n\\n    // a margin to prevent from rounding when calc liquidity multiplier limit\\n    uint256 private constant MARGIN_FOR_LIQUIDITY_MIGRATION_ROUNDING = 1e9;\\n\\n    //\\n    // EVENTS\\n    //\\n    event SwapInput(Dir dir, uint256 quoteAssetAmount, uint256 baseAssetAmount);\\n    event SwapOutput(Dir dir, uint256 quoteAssetAmount, uint256 baseAssetAmount);\\n    event FundingRateUpdated(int256 rate, uint256 underlyingPrice);\\n    event ReserveSnapshotted(uint256 quoteAssetReserve, uint256 baseAssetReserve, uint256 timestamp);\\n    event LiquidityChanged(uint256 quoteReserve, uint256 baseReserve, int256 cumulativeNotional);\\n    event CapChanged(uint256 maxHoldingBaseAsset, uint256 openInterestNotionalCap);\\n    event Shutdown(uint256 settlementPrice);\\n    event PriceFeedUpdated(address priceFeed);\\n\\n    //\\n    // MODIFIERS\\n    //\\n    modifier onlyOpen() {\\n        require(open, \\\"amm was closed\\\");\\n        _;\\n    }\\n\\n    modifier onlyCounterParty() {\\n        require(counterParty == _msgSender(), \\\"caller is not counterParty\\\");\\n        _;\\n    }\\n\\n    //\\n    // enum and struct\\n    //\\n    struct ReserveSnapshot {\\n        Decimal.decimal quoteAssetReserve;\\n        Decimal.decimal baseAssetReserve;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n    // internal usage\\n    enum QuoteAssetDir { QUOTE_IN, QUOTE_OUT }\\n    // internal usage\\n    enum TwapCalcOption { RESERVE_ASSET, INPUT_ASSET }\\n\\n    // To record current base/quote asset to calculate TWAP\\n\\n    struct TwapInputAsset {\\n        Dir dir;\\n        Decimal.decimal assetAmount;\\n        QuoteAssetDir inOrOut;\\n    }\\n\\n    struct TwapPriceCalcParams {\\n        TwapCalcOption opt;\\n        uint256 snapshotIndex;\\n        TwapInputAsset asset;\\n    }\\n\\n    //\\n    // Constant\\n    //\\n    // 10%\\n    uint256 public constant MAX_ORACLE_SPREAD_RATIO = 1e17;\\n\\n    //**********************************************************//\\n    //    The below state variables can not change the order    //\\n    //**********************************************************//\\n\\n    // DEPRECATED\\n    // update during every swap and calculate total amm pnl per funding period\\n    SignedDecimal.signedDecimal private baseAssetDeltaThisFundingPeriod;\\n\\n    // update during every swap and used when shutting amm down. it's trader's total base asset size\\n    SignedDecimal.signedDecimal public totalPositionSize;\\n\\n    // latest funding rate = ((twap market price - twap oracle price) / twap oracle price) / 24\\n    SignedDecimal.signedDecimal public fundingRate;\\n\\n    SignedDecimal.signedDecimal private cumulativeNotional;\\n\\n    Decimal.decimal private settlementPrice;\\n    Decimal.decimal public tradeLimitRatio;\\n    Decimal.decimal public quoteAssetReserve;\\n    Decimal.decimal public baseAssetReserve;\\n    Decimal.decimal public fluctuationLimitRatio;\\n\\n    // owner can update\\n    Decimal.decimal public tollRatio;\\n    Decimal.decimal public spreadRatio;\\n    Decimal.decimal public tollAmount;\\n    Decimal.decimal private maxHoldingBaseAsset;\\n    Decimal.decimal private openInterestNotionalCap;\\n\\n    // init cumulativePositionMultiplier is 1, will be updated every time when amm reserve increase/decrease\\n    Decimal.decimal private cumulativePositionMultiplier;\\n\\n    // snapshot of amm reserve when change liquidity's invariant\\n    LiquidityChangedSnapshot[] private liquidityChangedSnapshots;\\n\\n    uint256 public spotPriceTwapInterval;\\n    uint256 public fundingPeriod;\\n    uint256 public fundingBufferPeriod;\\n    uint256 public nextFundingTime;\\n    bytes32 public priceFeedKey;\\n    ReserveSnapshot[] public reserveSnapshots;\\n\\n    address private counterParty;\\n    address public globalShutdown;\\n    IERC20 public override quoteAsset;\\n    IPriceFeed public priceFeed;\\n    bool public override open;\\n    uint256[50] private __gap;\\n\\n    //**********************************************************//\\n    //    The above state variables can not change the order    //\\n    //**********************************************************//\\n\\n    //\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4 add state variables below \\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4//\\n\\n    //\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3 add state variables above \\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3//\\n\\n    //\\n    // FUNCTIONS\\n    //\\n    function initialize(\\n        uint256 _quoteAssetReserve,\\n        uint256 _baseAssetReserve,\\n        uint256 _tradeLimitRatio,\\n        uint256 _fundingPeriod,\\n        IPriceFeed _priceFeed,\\n        bytes32 _priceFeedKey,\\n        address _quoteAsset,\\n        uint256 _fluctuationLimitRatio,\\n        uint256 _tollRatio,\\n        uint256 _spreadRatio\\n    ) public initializer {\\n        require(\\n            _quoteAssetReserve != 0 &&\\n                _tradeLimitRatio != 0 &&\\n                _baseAssetReserve != 0 &&\\n                _fundingPeriod != 0 &&\\n                address(_priceFeed) != address(0) &&\\n                _quoteAsset != address(0),\\n            \\\"invalid input\\\"\\n        );\\n        __Ownable_init();\\n\\n        quoteAssetReserve = Decimal.decimal(_quoteAssetReserve);\\n        baseAssetReserve = Decimal.decimal(_baseAssetReserve);\\n        tradeLimitRatio = Decimal.decimal(_tradeLimitRatio);\\n        tollRatio = Decimal.decimal(_tollRatio);\\n        spreadRatio = Decimal.decimal(_spreadRatio);\\n        fluctuationLimitRatio = Decimal.decimal(_fluctuationLimitRatio);\\n        fundingPeriod = _fundingPeriod;\\n        fundingBufferPeriod = _fundingPeriod.div(2);\\n        spotPriceTwapInterval = 1 hours;\\n        priceFeedKey = _priceFeedKey;\\n        quoteAsset = IERC20(_quoteAsset);\\n        priceFeed = _priceFeed;\\n        cumulativePositionMultiplier = Decimal.one();\\n        liquidityChangedSnapshots.push(\\n            LiquidityChangedSnapshot({\\n                cumulativeNotional: SignedDecimal.zero(),\\n                baseAssetReserve: baseAssetReserve,\\n                quoteAssetReserve: quoteAssetReserve,\\n                totalPositionSize: SignedDecimal.zero()\\n            })\\n        );\\n        reserveSnapshots.push(ReserveSnapshot(quoteAssetReserve, baseAssetReserve, _blockTimestamp(), _blockNumber()));\\n        emit ReserveSnapshotted(quoteAssetReserve.toUint(), baseAssetReserve.toUint(), _blockTimestamp());\\n    }\\n\\n    /**\\n     * @notice Swap your quote asset to base asset, the impact of the price MUST be less than `fluctuationLimitRatio`\\n     * @dev Only clearingHouse can call this function\\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short\\n     * @param _quoteAssetAmount quote asset amount\\n     * @param _baseAssetAmountLimit minimum base asset amount expected to get to prevent front running\\n     * @param _canOverFluctuationLimit if tx can go over fluctuation limit once; for partial liquidation\\n     * @return base asset amount\\n     */\\n    function swapInput(\\n        Dir _dirOfQuote,\\n        Decimal.decimal calldata _quoteAssetAmount,\\n        Decimal.decimal calldata _baseAssetAmountLimit,\\n        bool _canOverFluctuationLimit\\n    ) external override onlyOpen onlyCounterParty returns (Decimal.decimal memory) {\\n        if (_quoteAssetAmount.toUint() == 0) {\\n            return Decimal.zero();\\n        }\\n        if (_dirOfQuote == Dir.REMOVE_FROM_AMM) {\\n            require(\\n                quoteAssetReserve.mulD(tradeLimitRatio).toUint() >= _quoteAssetAmount.toUint(),\\n                \\\"over trading limit\\\"\\n            );\\n        }\\n\\n        Decimal.decimal memory baseAssetAmount = getInputPrice(_dirOfQuote, _quoteAssetAmount);\\n        // If LONG, exchanged base amount should be more than _baseAssetAmountLimit,\\n        // otherwise(SHORT), exchanged base amount should be less than _baseAssetAmountLimit.\\n        // In SHORT case, more position means more debt so should not be larger than _baseAssetAmountLimit\\n        if (_baseAssetAmountLimit.toUint() != 0) {\\n            if (_dirOfQuote == Dir.ADD_TO_AMM) {\\n                require(baseAssetAmount.toUint() >= _baseAssetAmountLimit.toUint(), \\\"Less than minimal base token\\\");\\n            } else {\\n                require(baseAssetAmount.toUint() <= _baseAssetAmountLimit.toUint(), \\\"More than maximal base token\\\");\\n            }\\n        }\\n\\n        updateReserve(_dirOfQuote, _quoteAssetAmount, baseAssetAmount, _canOverFluctuationLimit);\\n        emit SwapInput(_dirOfQuote, _quoteAssetAmount.toUint(), baseAssetAmount.toUint());\\n        return baseAssetAmount;\\n    }\\n\\n    /**\\n     * @notice swap your base asset to quote asset; NOTE it is only used during close/liquidate positions so it always allows going over fluctuation limit\\n     * @dev only clearingHouse can call this function\\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from swapInput\\n     * @param _baseAssetAmount base asset amount\\n     * @param _quoteAssetAmountLimit limit of quote asset amount; for slippage protection\\n     * @return quote asset amount\\n     */\\n    function swapOutput(\\n        Dir _dirOfBase,\\n        Decimal.decimal calldata _baseAssetAmount,\\n        Decimal.decimal calldata _quoteAssetAmountLimit\\n    ) external override onlyOpen onlyCounterParty returns (Decimal.decimal memory) {\\n        return implSwapOutput(_dirOfBase, _baseAssetAmount, _quoteAssetAmountLimit);\\n    }\\n\\n    /**\\n     * @notice update funding rate\\n     * @dev only allow to update while reaching `nextFundingTime`\\n     * @return premium fraction of this period in 18 digits\\n     */\\n    function settleFunding() external override onlyOpen onlyCounterParty returns (SignedDecimal.signedDecimal memory) {\\n        require(_blockTimestamp() >= nextFundingTime, \\\"settle funding too early\\\");\\n\\n        // premium = twapMarketPrice - vwapIndexPrice\\n        // timeFraction = fundingPeriod(1 hour) / 1 day\\n        // premiumFraction = premium * timeFraction\\n        Decimal.decimal memory underlyingPrice = getUnderlyingPrice();\\n        SignedDecimal.signedDecimal memory premium =\\n            MixedDecimal.fromDecimal(getTwapPrice(spotPriceTwapInterval)).subD(underlyingPrice);\\n        SignedDecimal.signedDecimal memory premiumFraction = premium.mulScalar(fundingPeriod).divScalar(int256(1 days));\\n\\n        // update funding rate = premiumFraction / twapIndexPrice\\n        updateFundingRate(premiumFraction, underlyingPrice);\\n\\n        // in order to prevent multiple funding settlement during very short time after network congestion\\n        uint256 minNextValidFundingTime = _blockTimestamp().add(fundingBufferPeriod);\\n\\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\\n        uint256 nextFundingTimeOnHourStart = nextFundingTime.add(fundingPeriod).div(1 hours).mul(1 hours);\\n\\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\\n            ? nextFundingTimeOnHourStart\\n            : minNextValidFundingTime;\\n\\n        // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\\n        // reset funding related states\\n        baseAssetDeltaThisFundingPeriod = SignedDecimal.zero();\\n\\n        return premiumFraction;\\n    }\\n\\n    function calcBaseAssetAfterLiquidityMigration(\\n        SignedDecimal.signedDecimal memory _baseAssetAmount,\\n        Decimal.decimal memory _fromQuoteReserve,\\n        Decimal.decimal memory _fromBaseReserve\\n    ) public view override returns (SignedDecimal.signedDecimal memory) {\\n        if (_baseAssetAmount.toUint() == 0) {\\n            return _baseAssetAmount;\\n        }\\n\\n        bool isPositiveValue = _baseAssetAmount.toInt() > 0 ? true : false;\\n\\n        // measure the trader position's notional value on the old curve\\n        // (by simulating closing the position)\\n        Decimal.decimal memory posNotional =\\n            getOutputPriceWithReserves(\\n                isPositiveValue ? Dir.ADD_TO_AMM : Dir.REMOVE_FROM_AMM,\\n                _baseAssetAmount.abs(),\\n                _fromQuoteReserve,\\n                _fromBaseReserve\\n            );\\n\\n        // calculate and apply the required size on the new curve\\n        SignedDecimal.signedDecimal memory newBaseAsset =\\n            MixedDecimal.fromDecimal(\\n                getInputPrice(isPositiveValue ? Dir.REMOVE_FROM_AMM : Dir.ADD_TO_AMM, posNotional)\\n            );\\n        return newBaseAsset.mulScalar(isPositiveValue ? 1 : int256(-1));\\n    }\\n\\n    /**\\n     * @notice shutdown amm,\\n     * @dev only `globalShutdown` or owner can call this function\\n     * The price calculation is in `globalShutdown`.\\n     */\\n    function shutdown() external override {\\n        require(_msgSender() == owner() || _msgSender() == globalShutdown, \\\"not owner nor globalShutdown\\\");\\n        implShutdown();\\n    }\\n\\n    /**\\n     * @notice set counter party\\n     * @dev only owner can call this function\\n     * @param _counterParty address of counter party\\n     */\\n    function setCounterParty(address _counterParty) external onlyOwner {\\n        counterParty = _counterParty;\\n    }\\n\\n    /**\\n     * @notice set `globalShutdown`\\n     * @dev only owner can call this function\\n     * @param _globalShutdown address of `globalShutdown`\\n     */\\n    function setGlobalShutdown(address _globalShutdown) external onlyOwner {\\n        globalShutdown = _globalShutdown;\\n    }\\n\\n    /**\\n     * @notice set fluctuation limit rate. Default value is `1 / max leverage`\\n     * @dev only owner can call this function\\n     * @param _fluctuationLimitRatio fluctuation limit rate in 18 digits, 0 means skip the checking\\n     */\\n    function setFluctuationLimitRatio(Decimal.decimal memory _fluctuationLimitRatio) public onlyOwner {\\n        fluctuationLimitRatio = _fluctuationLimitRatio;\\n    }\\n\\n    /**\\n     * @notice set time interval for twap calculation, default is 1 hour\\n     * @dev only owner can call this function\\n     * @param _interval time interval in seconds\\n     */\\n    function setSpotPriceTwapInterval(uint256 _interval) external onlyOwner {\\n        require(_interval != 0, \\\"can not set interval to 0\\\");\\n        spotPriceTwapInterval = _interval;\\n    }\\n\\n    /**\\n     * @notice set `open` flag. Amm is open to trade if `open` is true. Default is false.\\n     * @dev only owner can call this function\\n     * @param _open open to trade is true, otherwise is false.\\n     */\\n    function setOpen(bool _open) external onlyOwner {\\n        if (open == _open) return;\\n\\n        open = _open;\\n        if (_open) {\\n            nextFundingTime = _blockTimestamp().add(fundingPeriod).div(1 hours).mul(1 hours);\\n        }\\n    }\\n\\n    /**\\n     * @notice set new toll ratio\\n     * @dev only owner can call\\n     * @param _tollRatio new toll ratio in 18 digits\\n     */\\n    function setTollRatio(Decimal.decimal memory _tollRatio) public onlyOwner {\\n        tollRatio = _tollRatio;\\n    }\\n\\n    /**\\n     * @notice set new spread ratio\\n     * @dev only owner can call\\n     * @param _spreadRatio new toll spread in 18 digits\\n     */\\n    function setSpreadRatio(Decimal.decimal memory _spreadRatio) public onlyOwner {\\n        spreadRatio = _spreadRatio;\\n    }\\n\\n    /**\\n     * @notice set new cap during guarded period, which is max position size that traders can hold\\n     * @dev only owner can call. assume this will be removes soon once the guarded period has ended. must be set before opening amm\\n     * @param _maxHoldingBaseAsset max position size that traders can hold in 18 digits\\n     * @param _openInterestNotionalCap open interest cap, denominated in quoteToken\\n     */\\n    function setCap(Decimal.decimal memory _maxHoldingBaseAsset, Decimal.decimal memory _openInterestNotionalCap)\\n        public\\n        onlyOwner\\n    {\\n        maxHoldingBaseAsset = _maxHoldingBaseAsset;\\n        openInterestNotionalCap = _openInterestNotionalCap;\\n        emit CapChanged(maxHoldingBaseAsset.toUint(), openInterestNotionalCap.toUint());\\n    }\\n\\n    /**\\n     * @notice set priceFee address\\n     * @dev only owner can call\\n     * @param _priceFeed new price feed for this AMM\\n     */\\n    function setPriceFeed(IPriceFeed _priceFeed) public onlyOwner {\\n        require(address(_priceFeed) != address(0), \\\"invalid PriceFeed address\\\");\\n        priceFeed = _priceFeed;\\n        emit PriceFeedUpdated(address(priceFeed));\\n    }\\n\\n    //\\n    // VIEW FUNCTIONS\\n    //\\n\\n    function isOverFluctuationLimit(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        // Skip the check if the limit is 0\\n        if (fluctuationLimitRatio.toUint() == 0) {\\n            return false;\\n        }\\n\\n        (Decimal.decimal memory upperLimit, Decimal.decimal memory lowerLimit) = getPriceBoundariesOfLastBlock();\\n\\n        Decimal.decimal memory quoteAssetExchanged = getOutputPrice(_dirOfBase, _baseAssetAmount);\\n        Decimal.decimal memory price =\\n            (_dirOfBase == Dir.REMOVE_FROM_AMM)\\n                ? quoteAssetReserve.addD(quoteAssetExchanged).divD(baseAssetReserve.subD(_baseAssetAmount))\\n                : quoteAssetReserve.subD(quoteAssetExchanged).divD(baseAssetReserve.addD(_baseAssetAmount));\\n\\n        if (price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice get input twap amount.\\n     * returns how many base asset you will get with the input quote amount based on twap price.\\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short.\\n     * @param _quoteAssetAmount quote asset amount\\n     * @return base asset amount\\n     */\\n    function getInputTwap(Dir _dirOfQuote, Decimal.decimal memory _quoteAssetAmount)\\n        public\\n        view\\n        override\\n        returns (Decimal.decimal memory)\\n    {\\n        return implGetInputAssetTwapPrice(_dirOfQuote, _quoteAssetAmount, QuoteAssetDir.QUOTE_IN, 15 minutes);\\n    }\\n\\n    /**\\n     * @notice get output twap amount.\\n     * return how many quote asset you will get with the input base amount on twap price.\\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from `getInputTwap`.\\n     * @param _baseAssetAmount base asset amount\\n     * @return quote asset amount\\n     */\\n    function getOutputTwap(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\\n        public\\n        view\\n        override\\n        returns (Decimal.decimal memory)\\n    {\\n        return implGetInputAssetTwapPrice(_dirOfBase, _baseAssetAmount, QuoteAssetDir.QUOTE_OUT, 15 minutes);\\n    }\\n\\n    /**\\n     * @notice get input amount. returns how many base asset you will get with the input quote amount.\\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short.\\n     * @param _quoteAssetAmount quote asset amount\\n     * @return base asset amount\\n     */\\n    function getInputPrice(Dir _dirOfQuote, Decimal.decimal memory _quoteAssetAmount)\\n        public\\n        view\\n        override\\n        returns (Decimal.decimal memory)\\n    {\\n        return getInputPriceWithReserves(_dirOfQuote, _quoteAssetAmount, quoteAssetReserve, baseAssetReserve);\\n    }\\n\\n    /**\\n     * @notice get output price. return how many quote asset you will get with the input base amount\\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from `getInput`.\\n     * @param _baseAssetAmount base asset amount\\n     * @return quote asset amount\\n     */\\n    function getOutputPrice(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\\n        public\\n        view\\n        override\\n        returns (Decimal.decimal memory)\\n    {\\n        return getOutputPriceWithReserves(_dirOfBase, _baseAssetAmount, quoteAssetReserve, baseAssetReserve);\\n    }\\n\\n    /**\\n     * @notice get underlying price provided by oracle\\n     * @return underlying price\\n     */\\n    function getUnderlyingPrice() public view override returns (Decimal.decimal memory) {\\n        return Decimal.decimal(priceFeed.getPrice(priceFeedKey));\\n    }\\n\\n\\n    /**\\n     * @notice get spot price based on current quote/base asset reserve.\\n     * @return spot price\\n     */\\n    function getSpotPrice() public view override returns (Decimal.decimal memory) {\\n        return quoteAssetReserve.divD(baseAssetReserve);\\n    }\\n\\n    /**\\n     * @notice get twap price\\n     */\\n    function getTwapPrice(uint256 _intervalInSeconds) public view returns (Decimal.decimal memory) {\\n        return implGetReserveTwapPrice(_intervalInSeconds);\\n    }\\n\\n    /**\\n     * @notice get current quote/base asset reserve.\\n     * @return (quote asset reserve, base asset reserve)\\n     */\\n    function getReserve() external view returns (Decimal.decimal memory, Decimal.decimal memory) {\\n        return (quoteAssetReserve, baseAssetReserve);\\n    }\\n\\n    function getSnapshotLen() external view returns (uint256) {\\n        return reserveSnapshots.length;\\n    }\\n\\n    function getLiquidityHistoryLength() external view override returns (uint256) {\\n        return liquidityChangedSnapshots.length;\\n    }\\n\\n    function getCumulativeNotional() external view override returns (SignedDecimal.signedDecimal memory) {\\n        return cumulativeNotional;\\n    }\\n\\n    function getLatestLiquidityChangedSnapshots() public view returns (LiquidityChangedSnapshot memory) {\\n        return liquidityChangedSnapshots[liquidityChangedSnapshots.length.sub(1)];\\n    }\\n\\n    function getLiquidityChangedSnapshots(uint256 i) external view override returns (LiquidityChangedSnapshot memory) {\\n        require(i < liquidityChangedSnapshots.length, \\\"incorrect index\\\");\\n        return liquidityChangedSnapshots[i];\\n    }\\n\\n    function getSettlementPrice() external view override returns (Decimal.decimal memory) {\\n        return settlementPrice;\\n    }\\n\\n    // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\\n    function getBaseAssetDeltaThisFundingPeriod() external view override returns (SignedDecimal.signedDecimal memory) {\\n        return baseAssetDeltaThisFundingPeriod;\\n    }\\n\\n    function getMaxHoldingBaseAsset() external view override returns (Decimal.decimal memory) {\\n        return maxHoldingBaseAsset;\\n    }\\n\\n    function getOpenInterestNotionalCap() external view override returns (Decimal.decimal memory) {\\n        return openInterestNotionalCap;\\n    }\\n\\n    function getBaseAssetDelta() external view override returns (SignedDecimal.signedDecimal memory) {\\n        return totalPositionSize;\\n    }\\n\\n    function isOverSpreadLimit() external view override returns (bool) {\\n        Decimal.decimal memory oraclePrice = getUnderlyingPrice();\\n        require(oraclePrice.toUint() > 0, \\\"underlying price is 0\\\");\\n        Decimal.decimal memory marketPrice = getSpotPrice();\\n        Decimal.decimal memory oracleSpreadRatioAbs =\\n            MixedDecimal.fromDecimal(marketPrice).subD(oraclePrice).divD(oraclePrice).abs();\\n\\n        return oracleSpreadRatioAbs.toUint() >= MAX_ORACLE_SPREAD_RATIO ? true : false;\\n    }\\n\\n    /**\\n     * @notice calculate total fee (including toll and spread) by input quoteAssetAmount\\n     * @param _quoteAssetAmount quoteAssetAmount\\n     * @return total tx fee\\n     */\\n    function calcFee(Decimal.decimal calldata _quoteAssetAmount)\\n        external\\n        view\\n        override\\n        returns (Decimal.decimal memory, Decimal.decimal memory)\\n    {\\n        if (_quoteAssetAmount.toUint() == 0) {\\n            return (Decimal.zero(), Decimal.zero());\\n        }\\n        return (_quoteAssetAmount.mulD(tollRatio), _quoteAssetAmount.mulD(spreadRatio));\\n    }\\n\\n    /*       plus/minus 1 while the amount is not dividable\\n     *\\n     *        getInputPrice                         getOutputPrice\\n     *\\n     *     \\uff21\\uff24\\uff24      (amount - 1)              (amount + 1)   \\uff32\\uff25\\uff2d\\uff2f\\uff36\\uff25\\n     *      \\u25e5\\u25e4            \\u25b2                         |             \\u25e2\\u25e3\\n     *      \\u25e5\\u25e4  ------->  |                         \\u25bc  <--------  \\u25e2\\u25e3\\n     *    -------      -------                   -------        -------\\n     *    |  Q  |      |  B  |                   |  Q  |        |  B  |\\n     *    -------      -------                   -------        -------\\n     *      \\u25e5\\u25e4  ------->  \\u25b2                         |  <--------  \\u25e2\\u25e3\\n     *      \\u25e5\\u25e4            |                         \\u25bc             \\u25e2\\u25e3\\n     *   \\uff32\\uff25\\uff2d\\uff2f\\uff36\\uff25  (amount + 1)              (amount + 1)      \\uff21\\uff24\\uff24\\n     **/\\n\\n    function getInputPriceWithReserves(\\n        Dir _dirOfQuote,\\n        Decimal.decimal memory _quoteAssetAmount,\\n        Decimal.decimal memory _quoteAssetPoolAmount,\\n        Decimal.decimal memory _baseAssetPoolAmount\\n    ) public pure override returns (Decimal.decimal memory) {\\n        if (_quoteAssetAmount.toUint() == 0) {\\n            return Decimal.zero();\\n        }\\n\\n        bool isAddToAmm = _dirOfQuote == Dir.ADD_TO_AMM;\\n        SignedDecimal.signedDecimal memory invariant =\\n            MixedDecimal.fromDecimal(_quoteAssetPoolAmount.mulD(_baseAssetPoolAmount));\\n        SignedDecimal.signedDecimal memory baseAssetAfter;\\n        Decimal.decimal memory quoteAssetAfter;\\n        Decimal.decimal memory baseAssetBought;\\n        if (isAddToAmm) {\\n            quoteAssetAfter = _quoteAssetPoolAmount.addD(_quoteAssetAmount);\\n        } else {\\n            quoteAssetAfter = _quoteAssetPoolAmount.subD(_quoteAssetAmount);\\n        }\\n        require(quoteAssetAfter.toUint() != 0, \\\"quote asset after is 0\\\");\\n\\n        baseAssetAfter = invariant.divD(quoteAssetAfter);\\n        baseAssetBought = baseAssetAfter.subD(_baseAssetPoolAmount).abs();\\n\\n        // if the amount is not dividable, return 1 wei less for trader\\n        if (invariant.abs().modD(quoteAssetAfter).toUint() != 0) {\\n            if (isAddToAmm) {\\n                baseAssetBought = baseAssetBought.subD(Decimal.decimal(1));\\n            } else {\\n                baseAssetBought = baseAssetBought.addD(Decimal.decimal(1));\\n            }\\n        }\\n\\n        return baseAssetBought;\\n    }\\n\\n    function getOutputPriceWithReserves(\\n        Dir _dirOfBase,\\n        Decimal.decimal memory _baseAssetAmount,\\n        Decimal.decimal memory _quoteAssetPoolAmount,\\n        Decimal.decimal memory _baseAssetPoolAmount\\n    ) public pure override returns (Decimal.decimal memory) {\\n        if (_baseAssetAmount.toUint() == 0) {\\n            return Decimal.zero();\\n        }\\n\\n        bool isAddToAmm = _dirOfBase == Dir.ADD_TO_AMM;\\n        SignedDecimal.signedDecimal memory invariant =\\n            MixedDecimal.fromDecimal(_quoteAssetPoolAmount.mulD(_baseAssetPoolAmount));\\n        SignedDecimal.signedDecimal memory quoteAssetAfter;\\n        Decimal.decimal memory baseAssetAfter;\\n        Decimal.decimal memory quoteAssetSold;\\n\\n        if (isAddToAmm) {\\n            baseAssetAfter = _baseAssetPoolAmount.addD(_baseAssetAmount);\\n        } else {\\n            baseAssetAfter = _baseAssetPoolAmount.subD(_baseAssetAmount);\\n        }\\n        require(baseAssetAfter.toUint() != 0, \\\"base asset after is 0\\\");\\n\\n        quoteAssetAfter = invariant.divD(baseAssetAfter);\\n        quoteAssetSold = quoteAssetAfter.subD(_quoteAssetPoolAmount).abs();\\n\\n        // if the amount is not dividable, return 1 wei less for trader\\n        if (invariant.abs().modD(baseAssetAfter).toUint() != 0) {\\n            if (isAddToAmm) {\\n                quoteAssetSold = quoteAssetSold.subD(Decimal.decimal(1));\\n            } else {\\n                quoteAssetSold = quoteAssetSold.addD(Decimal.decimal(1));\\n            }\\n        }\\n\\n        return quoteAssetSold;\\n    }\\n\\n    //\\n    // INTERNAL FUNCTIONS\\n    //\\n    // update funding rate = premiumFraction / twapIndexPrice\\n    function updateFundingRate(\\n        SignedDecimal.signedDecimal memory _premiumFraction,\\n        Decimal.decimal memory _underlyingPrice\\n    ) private {\\n        fundingRate = _premiumFraction.divD(_underlyingPrice);\\n        emit FundingRateUpdated(fundingRate.toInt(), _underlyingPrice.toUint());\\n    }\\n\\n    function addReserveSnapshot() internal {\\n        uint256 currentBlock = _blockNumber();\\n        ReserveSnapshot storage latestSnapshot = reserveSnapshots[reserveSnapshots.length - 1];\\n        // update values in snapshot if in the same block\\n        if (currentBlock == latestSnapshot.blockNumber) {\\n            latestSnapshot.quoteAssetReserve = quoteAssetReserve;\\n            latestSnapshot.baseAssetReserve = baseAssetReserve;\\n        } else {\\n            reserveSnapshots.push(\\n                ReserveSnapshot(quoteAssetReserve, baseAssetReserve, _blockTimestamp(), currentBlock)\\n            );\\n        }\\n        emit ReserveSnapshotted(quoteAssetReserve.toUint(), baseAssetReserve.toUint(), _blockTimestamp());\\n    }\\n\\n    function implSwapOutput(\\n        Dir _dirOfBase,\\n        Decimal.decimal memory _baseAssetAmount,\\n        Decimal.decimal memory _quoteAssetAmountLimit\\n    ) internal returns (Decimal.decimal memory) {\\n        if (_baseAssetAmount.toUint() == 0) {\\n            return Decimal.zero();\\n        }\\n        if (_dirOfBase == Dir.REMOVE_FROM_AMM) {\\n            require(baseAssetReserve.mulD(tradeLimitRatio).toUint() >= _baseAssetAmount.toUint(), \\\"over trading limit\\\");\\n        }\\n\\n        Decimal.decimal memory quoteAssetAmount = getOutputPrice(_dirOfBase, _baseAssetAmount);\\n        Dir dirOfQuote = _dirOfBase == Dir.ADD_TO_AMM ? Dir.REMOVE_FROM_AMM : Dir.ADD_TO_AMM;\\n        // If SHORT, exchanged quote amount should be less than _quoteAssetAmountLimit,\\n        // otherwise(LONG), exchanged base amount should be more than _quoteAssetAmountLimit.\\n        // In the SHORT case, more quote assets means more payment so should not be more than _quoteAssetAmountLimit\\n        if (_quoteAssetAmountLimit.toUint() != 0) {\\n            if (dirOfQuote == Dir.REMOVE_FROM_AMM) {\\n                // SHORT\\n                require(quoteAssetAmount.toUint() >= _quoteAssetAmountLimit.toUint(), \\\"Less than minimal quote token\\\");\\n            } else {\\n                // LONG\\n                require(quoteAssetAmount.toUint() <= _quoteAssetAmountLimit.toUint(), \\\"More than maximal quote token\\\");\\n            }\\n        }\\n\\n        // as mentioned in swapOutput(), it always allows going over fluctuation limit because\\n        // it is only used by close/liquidate positions\\n        updateReserve(dirOfQuote, quoteAssetAmount, _baseAssetAmount, true);\\n        emit SwapOutput(_dirOfBase, quoteAssetAmount.toUint(), _baseAssetAmount.toUint());\\n        return quoteAssetAmount;\\n    }\\n\\n    // the direction is in quote asset\\n    function updateReserve(\\n        Dir _dirOfQuote,\\n        Decimal.decimal memory _quoteAssetAmount,\\n        Decimal.decimal memory _baseAssetAmount,\\n        bool _canOverFluctuationLimit\\n    ) internal {\\n        // check if it's over fluctuationLimitRatio\\n        // this check should be before reserves being updated\\n        checkIsOverBlockFluctuationLimit(_dirOfQuote, _quoteAssetAmount, _baseAssetAmount, _canOverFluctuationLimit);\\n\\n        if (_dirOfQuote == Dir.ADD_TO_AMM) {\\n            quoteAssetReserve = quoteAssetReserve.addD(_quoteAssetAmount);\\n            baseAssetReserve = baseAssetReserve.subD(_baseAssetAmount);\\n            // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\\n            baseAssetDeltaThisFundingPeriod = baseAssetDeltaThisFundingPeriod.subD(_baseAssetAmount);\\n            totalPositionSize = totalPositionSize.addD(_baseAssetAmount);\\n            cumulativeNotional = cumulativeNotional.addD(_quoteAssetAmount);\\n        } else {\\n            quoteAssetReserve = quoteAssetReserve.subD(_quoteAssetAmount);\\n            baseAssetReserve = baseAssetReserve.addD(_baseAssetAmount);\\n            // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\\n            baseAssetDeltaThisFundingPeriod = baseAssetDeltaThisFundingPeriod.addD(_baseAssetAmount);\\n            totalPositionSize = totalPositionSize.subD(_baseAssetAmount);\\n            cumulativeNotional = cumulativeNotional.subD(_quoteAssetAmount);\\n        }\\n\\n        // addReserveSnapshot must be after checking price fluctuation\\n        addReserveSnapshot();\\n    }\\n\\n    function implGetInputAssetTwapPrice(\\n        Dir _dirOfQuote,\\n        Decimal.decimal memory _assetAmount,\\n        QuoteAssetDir _inOut,\\n        uint256 _interval\\n    ) internal view returns (Decimal.decimal memory) {\\n        TwapPriceCalcParams memory params;\\n        params.opt = TwapCalcOption.INPUT_ASSET;\\n        params.snapshotIndex = reserveSnapshots.length.sub(1);\\n        params.asset.dir = _dirOfQuote;\\n        params.asset.assetAmount = _assetAmount;\\n        params.asset.inOrOut = _inOut;\\n        return calcTwap(params, _interval);\\n    }\\n\\n    function implGetReserveTwapPrice(uint256 _interval) internal view returns (Decimal.decimal memory) {\\n        TwapPriceCalcParams memory params;\\n        params.opt = TwapCalcOption.RESERVE_ASSET;\\n        params.snapshotIndex = reserveSnapshots.length.sub(1);\\n        return calcTwap(params, _interval);\\n    }\\n\\n    function calcTwap(TwapPriceCalcParams memory _params, uint256 _interval)\\n        internal\\n        view\\n        returns (Decimal.decimal memory)\\n    {\\n        Decimal.decimal memory currentPrice = getPriceWithSpecificSnapshot(_params);\\n        if (_interval == 0) {\\n            return currentPrice;\\n        }\\n\\n        uint256 baseTimestamp = _blockTimestamp().sub(_interval);\\n        ReserveSnapshot memory currentSnapshot = reserveSnapshots[_params.snapshotIndex];\\n        // return the latest snapshot price directly\\n        // if only one snapshot or the timestamp of latest snapshot is earlier than asking for\\n        if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {\\n            return currentPrice;\\n        }\\n\\n        uint256 previousTimestamp = currentSnapshot.timestamp;\\n        uint256 period = _blockTimestamp().sub(previousTimestamp);\\n        Decimal.decimal memory weightedPrice = currentPrice.mulScalar(period);\\n        while (true) {\\n            // if snapshot history is too short\\n            if (_params.snapshotIndex == 0) {\\n                return weightedPrice.divScalar(period);\\n            }\\n\\n            _params.snapshotIndex = _params.snapshotIndex.sub(1);\\n            currentSnapshot = reserveSnapshots[_params.snapshotIndex];\\n            currentPrice = getPriceWithSpecificSnapshot(_params);\\n\\n            // check if current round timestamp is earlier than target timestamp\\n            if (currentSnapshot.timestamp <= baseTimestamp) {\\n                // weighted time period will be (target timestamp - previous timestamp). For example,\\n                // now is 1000, _interval is 100, then target timestamp is 900. If timestamp of current round is 970,\\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\\n                // instead of (970 - 880)\\n                weightedPrice = weightedPrice.addD(currentPrice.mulScalar(previousTimestamp.sub(baseTimestamp)));\\n                break;\\n            }\\n\\n            uint256 timeFraction = previousTimestamp.sub(currentSnapshot.timestamp);\\n            weightedPrice = weightedPrice.addD(currentPrice.mulScalar(timeFraction));\\n            period = period.add(timeFraction);\\n            previousTimestamp = currentSnapshot.timestamp;\\n        }\\n        return weightedPrice.divScalar(_interval);\\n    }\\n\\n    function getPriceWithSpecificSnapshot(TwapPriceCalcParams memory params)\\n        internal\\n        view\\n        virtual\\n        returns (Decimal.decimal memory)\\n    {\\n        ReserveSnapshot memory snapshot = reserveSnapshots[params.snapshotIndex];\\n\\n        // RESERVE_ASSET means price comes from quoteAssetReserve/baseAssetReserve\\n        // INPUT_ASSET means getInput/Output price with snapshot's reserve\\n        if (params.opt == TwapCalcOption.RESERVE_ASSET) {\\n            return snapshot.quoteAssetReserve.divD(snapshot.baseAssetReserve);\\n        } else if (params.opt == TwapCalcOption.INPUT_ASSET) {\\n            if (params.asset.assetAmount.toUint() == 0) {\\n                return Decimal.zero();\\n            }\\n            if (params.asset.inOrOut == QuoteAssetDir.QUOTE_IN) {\\n                return\\n                    getInputPriceWithReserves(\\n                        params.asset.dir,\\n                        params.asset.assetAmount,\\n                        snapshot.quoteAssetReserve,\\n                        snapshot.baseAssetReserve\\n                    );\\n            } else if (params.asset.inOrOut == QuoteAssetDir.QUOTE_OUT) {\\n                return\\n                    getOutputPriceWithReserves(\\n                        params.asset.dir,\\n                        params.asset.assetAmount,\\n                        snapshot.quoteAssetReserve,\\n                        snapshot.baseAssetReserve\\n                    );\\n            }\\n        }\\n        revert(\\\"not supported option\\\");\\n    }\\n\\n    function getPriceBoundariesOfLastBlock() internal view returns (Decimal.decimal memory, Decimal.decimal memory) {\\n        uint256 len = reserveSnapshots.length;\\n        ReserveSnapshot memory latestSnapshot = reserveSnapshots[len.sub(1)];\\n        // if the latest snapshot is the same as current block, get the previous one\\n        if (latestSnapshot.blockNumber == _blockNumber() && len > 1) {\\n            latestSnapshot = reserveSnapshots[len.sub(2)];\\n        }\\n\\n        Decimal.decimal memory lastPrice = latestSnapshot.quoteAssetReserve.divD(latestSnapshot.baseAssetReserve);\\n        Decimal.decimal memory upperLimit = lastPrice.mulD(Decimal.one().addD(fluctuationLimitRatio));\\n        Decimal.decimal memory lowerLimit = lastPrice.mulD(Decimal.one().subD(fluctuationLimitRatio));\\n        return (upperLimit, lowerLimit);\\n    }\\n\\n    /**\\n     * @notice there can only be one tx in a block can skip the fluctuation check\\n     *         otherwise, some positions can never be closed or liquidated\\n     * @param _canOverFluctuationLimit if true, can skip fluctuation check for once; else, can never skip\\n     */\\n    function checkIsOverBlockFluctuationLimit(\\n        Dir _dirOfQuote,\\n        Decimal.decimal memory _quoteAssetAmount,\\n        Decimal.decimal memory _baseAssetAmount,\\n        bool _canOverFluctuationLimit\\n    ) internal view {\\n        // Skip the check if the limit is 0\\n        if (fluctuationLimitRatio.toUint() == 0) {\\n            return;\\n        }\\n\\n        //\\n        // assume the price of the last block is 10, fluctuation limit ratio is 5%, then\\n        //\\n        //          current price\\n        //  --+---------+-----------+---\\n        //   9.5        10         10.5\\n        // lower limit           upper limit\\n        //\\n        // when `openPosition`, the price can only be between 9.5 - 10.5\\n        // when `liquidate` and `closePosition`, the price can exceed the boundary once\\n        // (either lower than 9.5 or higher than 10.5)\\n        // once it exceeds the boundary, all the rest txs in this block fail\\n        //\\n\\n        (Decimal.decimal memory upperLimit, Decimal.decimal memory lowerLimit) = getPriceBoundariesOfLastBlock();\\n\\n        Decimal.decimal memory price = quoteAssetReserve.divD(baseAssetReserve);\\n        require(price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0, \\\"price is already over fluctuation limit\\\");\\n\\n        if (!_canOverFluctuationLimit) {\\n            price = (_dirOfQuote == Dir.ADD_TO_AMM)\\n                ? quoteAssetReserve.addD(_quoteAssetAmount).divD(baseAssetReserve.subD(_baseAssetAmount))\\n                : quoteAssetReserve.subD(_quoteAssetAmount).divD(baseAssetReserve.addD(_baseAssetAmount));\\n            require(price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0, \\\"price is over fluctuation limit\\\");\\n        }\\n    }\\n\\n    function checkLiquidityMultiplierLimit(\\n        SignedDecimal.signedDecimal memory _positionSize,\\n        Decimal.decimal memory _liquidityMultiplier\\n    ) internal view {\\n        // have lower bound when position size is long\\n        if (_positionSize.toInt() > 0) {\\n            Decimal.decimal memory liquidityMultiplierLowerBound =\\n                _positionSize\\n                    .addD(Decimal.decimal(MARGIN_FOR_LIQUIDITY_MIGRATION_ROUNDING))\\n                    .divD(baseAssetReserve)\\n                    .abs();\\n            require(_liquidityMultiplier.cmp(liquidityMultiplierLowerBound) >= 0, \\\"illegal liquidity multiplier\\\");\\n        }\\n    }\\n\\n    function implShutdown() internal {\\n        LiquidityChangedSnapshot memory latestLiquiditySnapshot = getLatestLiquidityChangedSnapshots();\\n\\n        // get last liquidity changed history to calc new quote/base reserve\\n        Decimal.decimal memory previousK =\\n            latestLiquiditySnapshot.baseAssetReserve.mulD(latestLiquiditySnapshot.quoteAssetReserve);\\n        SignedDecimal.signedDecimal memory lastInitBaseReserveInNewCurve =\\n            latestLiquiditySnapshot.totalPositionSize.addD(latestLiquiditySnapshot.baseAssetReserve);\\n        SignedDecimal.signedDecimal memory lastInitQuoteReserveInNewCurve =\\n            MixedDecimal.fromDecimal(previousK).divD(lastInitBaseReserveInNewCurve);\\n\\n        // settlementPrice = SUM(Open Position Notional Value) / SUM(Position Size)\\n        // `Open Position Notional Value` = init quote reserve - current quote reserve\\n        // `Position Size` = init base reserve - current base reserve\\n        SignedDecimal.signedDecimal memory positionNotionalValue =\\n            lastInitQuoteReserveInNewCurve.subD(quoteAssetReserve);\\n\\n        // if total position size less than IGNORABLE_DIGIT_FOR_SHUTDOWN, treat it as 0 positions due to rounding error\\n        if (totalPositionSize.toUint() > IGNORABLE_DIGIT_FOR_SHUTDOWN) {\\n            settlementPrice = positionNotionalValue.abs().divD(totalPositionSize.abs());\\n        }\\n\\n        open = false;\\n        emit Shutdown(settlementPrice.toUint());\\n    }\\n}\\n\",\"keccak256\":\"0x441de4a2d0a0bf971c7ee8e9819d6e9e5935ff3174d08d7f82d72b35151d40ef\",\"license\":\"GPL-3.0-or-later\"},\"contracts/AmmReader.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\npragma experimental ABIEncoderV2;\\n\\nimport { Amm } from \\\"./Amm.sol\\\";\\nimport { Decimal } from \\\"./utils/MixedDecimal.sol\\\";\\n\\ncontract AmmReader {\\n    using Decimal for Decimal.decimal;\\n    struct AmmStates {\\n        uint256 quoteAssetReserve;\\n        uint256 baseAssetReserve;\\n        uint256 tradeLimitRatio;\\n        uint256 fundingPeriod;\\n        string quoteAssetSymbol;\\n        string baseAssetSymbol;\\n        bytes32 priceFeedKey;\\n        address priceFeed;\\n    }\\n\\n    function getAmmStates(address _amm) external view returns (AmmStates memory) {\\n        Amm amm = Amm(_amm);\\n        (bool getSymbolSuccess, bytes memory quoteAssetSymbolData) =\\n            address(amm.quoteAsset()).staticcall(abi.encodeWithSignature(\\\"symbol()\\\"));\\n        (Decimal.decimal memory quoteAssetReserve, Decimal.decimal memory baseAssetReserve) = amm.getReserve();\\n\\n        bytes32 priceFeedKey = amm.priceFeedKey();\\n        return\\n            AmmStates({\\n                quoteAssetReserve: quoteAssetReserve.toUint(),\\n                baseAssetReserve: baseAssetReserve.toUint(),\\n                tradeLimitRatio: amm.tradeLimitRatio(),\\n                fundingPeriod: amm.fundingPeriod(),\\n                priceFeed: address(amm.priceFeed()),\\n                priceFeedKey: priceFeedKey,\\n                quoteAssetSymbol: getSymbolSuccess ? abi.decode(quoteAssetSymbolData, (string)) : \\\"\\\",\\n                baseAssetSymbol: bytes32ToString(priceFeedKey)\\n            });\\n    }\\n\\n    // TODO: move to library\\n    function bytes32ToString(bytes32 _key) private pure returns (string memory) {\\n        uint8 length;\\n        while (length < 32 && _key[length] != 0) {\\n            length++;\\n        }\\n        bytes memory bytesArray = new bytes(length);\\n        for (uint256 i = 0; i < 32 && _key[i] != 0; i++) {\\n            bytesArray[i] = _key[i];\\n        }\\n        return string(bytesArray);\\n    }\\n}\\n\",\"keccak256\":\"0xaea188de088a1468f41567c3bab771c3eec35b66952a2b2c8d1cddb5dddf4e57\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interface/IAmm.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Decimal} from \\\"../utils/Decimal.sol\\\";\\nimport {SignedDecimal} from \\\"../utils/SignedDecimal.sol\\\";\\n\\ninterface IAmm {\\n    /**\\n     * @notice asset direction, used in getInputPrice, getOutputPrice, swapInput and swapOutput\\n     * @param ADD_TO_AMM add asset to Amm\\n     * @param REMOVE_FROM_AMM remove asset from Amm\\n     */\\n    enum Dir {\\n        ADD_TO_AMM,\\n        REMOVE_FROM_AMM\\n    }\\n\\n    struct LiquidityChangedSnapshot {\\n        SignedDecimal.signedDecimal cumulativeNotional;\\n        // the base/quote reserve of amm right before liquidity changed\\n        Decimal.decimal quoteAssetReserve;\\n        Decimal.decimal baseAssetReserve;\\n        // total position size owned by amm after last snapshot taken\\n        // `totalPositionSize` = currentBaseAssetReserve - lastLiquidityChangedHistoryItem.baseAssetReserve + prevTotalPositionSize\\n        SignedDecimal.signedDecimal totalPositionSize;\\n    }\\n\\n    function swapInput(\\n        Dir _dir,\\n        Decimal.decimal calldata _quoteAssetAmount,\\n        Decimal.decimal calldata _baseAssetAmountLimit,\\n        bool _canOverFluctuationLimit\\n    ) external returns (Decimal.decimal memory);\\n\\n    function swapOutput(\\n        Dir _dir,\\n        Decimal.decimal calldata _baseAssetAmount,\\n        Decimal.decimal calldata _quoteAssetAmountLimit\\n    ) external returns (Decimal.decimal memory);\\n\\n    function shutdown() external;\\n\\n    function settleFunding() external returns (SignedDecimal.signedDecimal memory);\\n\\n    function calcFee(Decimal.decimal calldata _quoteAssetAmount)\\n        external\\n        view\\n        returns (Decimal.decimal memory, Decimal.decimal memory);\\n\\n    //\\n    // VIEW\\n    //\\n\\n    function isOverFluctuationLimit(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\\n        external\\n        view\\n        returns (bool);\\n\\n    function calcBaseAssetAfterLiquidityMigration(\\n        SignedDecimal.signedDecimal memory _baseAssetAmount,\\n        Decimal.decimal memory _fromQuoteReserve,\\n        Decimal.decimal memory _fromBaseReserve\\n    ) external view returns (SignedDecimal.signedDecimal memory);\\n\\n    function getInputTwap(Dir _dir, Decimal.decimal calldata _quoteAssetAmount)\\n        external\\n        view\\n        returns (Decimal.decimal memory);\\n\\n    function getOutputTwap(Dir _dir, Decimal.decimal calldata _baseAssetAmount)\\n        external\\n        view\\n        returns (Decimal.decimal memory);\\n\\n    function getInputPrice(Dir _dir, Decimal.decimal calldata _quoteAssetAmount)\\n        external\\n        view\\n        returns (Decimal.decimal memory);\\n\\n    function getOutputPrice(Dir _dir, Decimal.decimal calldata _baseAssetAmount)\\n        external\\n        view\\n        returns (Decimal.decimal memory);\\n\\n    function getInputPriceWithReserves(\\n        Dir _dir,\\n        Decimal.decimal memory _quoteAssetAmount,\\n        Decimal.decimal memory _quoteAssetPoolAmount,\\n        Decimal.decimal memory _baseAssetPoolAmount\\n    ) external pure returns (Decimal.decimal memory);\\n\\n    function getOutputPriceWithReserves(\\n        Dir _dir,\\n        Decimal.decimal memory _baseAssetAmount,\\n        Decimal.decimal memory _quoteAssetPoolAmount,\\n        Decimal.decimal memory _baseAssetPoolAmount\\n    ) external pure returns (Decimal.decimal memory);\\n\\n    function getSpotPrice() external view returns (Decimal.decimal memory);\\n\\n    function getLiquidityHistoryLength() external view returns (uint256);\\n\\n    // overridden by state variable\\n    function quoteAsset() external view returns (IERC20);\\n\\n    function open() external view returns (bool);\\n\\n    // can not be overridden by state variable due to type `Deciaml.decimal`\\n    function getSettlementPrice() external view returns (Decimal.decimal memory);\\n\\n    function getBaseAssetDeltaThisFundingPeriod()\\n        external\\n        view\\n        returns (SignedDecimal.signedDecimal memory);\\n\\n    function getCumulativeNotional() external view returns (SignedDecimal.signedDecimal memory);\\n\\n    function getMaxHoldingBaseAsset() external view returns (Decimal.decimal memory);\\n\\n    function getOpenInterestNotionalCap() external view returns (Decimal.decimal memory);\\n\\n    function getLiquidityChangedSnapshots(uint256 i)\\n        external\\n        view\\n        returns (LiquidityChangedSnapshot memory);\\n\\n    function getBaseAssetDelta() external view returns (SignedDecimal.signedDecimal memory);\\n\\n    function getUnderlyingPrice() external view returns (Decimal.decimal memory);\\n\\n    function isOverSpreadLimit() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xd7d5f998a5439e3776cc385cc68d32bd72b020e31037c025d1372c6bc0a4d768\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interface/IPriceFeed.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface IPriceFeed {\\n    // get latest price\\n    function getPrice(bytes32 _priceFeedKey) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xac71088b15d542724cdb376575728aae59399e0556c94b8ff079b20da804e720\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/BlockContext.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\n\\n// wrap block.xxx functions for testing\\n// only support timestamp and number so far\\nabstract contract BlockContext {\\n    //\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4 add state variables below \\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4\\u25e5\\u25e4//\\n\\n    //\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3 add state variables above \\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3\\u25e2\\u25e3//\\n    uint256[50] private __gap;\\n\\n    function _blockTimestamp() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function _blockNumber() internal view virtual returns (uint256) {\\n        return block.number;\\n    }\\n}\\n\",\"keccak256\":\"0xd1b1f2a5a3cce33f04b4f3ea1d7c3112d27ec6ab14e46dcdc9d68e7ff52b6446\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/Decimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <=0.9.0;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport {DecimalMath} from \\\"./DecimalMath.sol\\\";\\n\\nlibrary Decimal {\\n    using DecimalMath for uint256;\\n    using SafeMath for uint256;\\n\\n    struct decimal {\\n        uint256 d;\\n    }\\n\\n    function zero() internal pure returns (decimal memory) {\\n        return decimal(0);\\n    }\\n\\n    function one() internal pure returns (decimal memory) {\\n        return decimal(DecimalMath.unit(18));\\n    }\\n\\n    function toUint(decimal memory x) internal pure returns (uint256) {\\n        return x.d;\\n    }\\n\\n    function modD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\\n        return decimal(x.d.mul(DecimalMath.unit(18)) % y.d);\\n    }\\n\\n    function cmp(decimal memory x, decimal memory y) internal pure returns (int8) {\\n        if (x.d > y.d) {\\n            return 1;\\n        } else if (x.d < y.d) {\\n            return -1;\\n        }\\n        return 0;\\n    }\\n\\n    /// @dev add two decimals\\n    function addD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\\n        decimal memory t;\\n        t.d = x.d.add(y.d);\\n        return t;\\n    }\\n\\n    /// @dev subtract two decimals\\n    function subD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\\n        decimal memory t;\\n        t.d = x.d.sub(y.d);\\n        return t;\\n    }\\n\\n    /// @dev multiple two decimals\\n    function mulD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\\n        decimal memory t;\\n        t.d = x.d.muld(y.d);\\n        return t;\\n    }\\n\\n    /// @dev multiple a decimal by a uint256\\n    function mulScalar(decimal memory x, uint256 y) internal pure returns (decimal memory) {\\n        decimal memory t;\\n        t.d = x.d.mul(y);\\n        return t;\\n    }\\n\\n    /// @dev divide two decimals\\n    function divD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\\n        decimal memory t;\\n        t.d = x.d.divd(y.d);\\n        return t;\\n    }\\n\\n    /// @dev divide a decimal by a uint256\\n    function divScalar(decimal memory x, uint256 y) internal pure returns (decimal memory) {\\n        decimal memory t;\\n        t.d = x.d.div(y);\\n        return t;\\n    }\\n}\\n\",\"keccak256\":\"0x1db4f74edd20aa77b0ed6732de1d6fcbdfed4fe79e042f459dda6e26584ee574\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/DecimalMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/// @dev Implements simple fixed point math add, sub, mul and div operations.\\n/// @author Alberto Cuesta Ca\\u00f1ada\\nlibrary DecimalMath {\\n    using SafeMath for uint256;\\n\\n    /// @dev Returns 1 in the fixed point representation, with `decimals` decimals.\\n    function unit(uint8 decimals) internal pure returns (uint256) {\\n        return 10**uint256(decimals);\\n    }\\n\\n    /// @dev Adds x and y, assuming they are both fixed point with 18 decimals.\\n    function addd(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x.add(y);\\n    }\\n\\n    /// @dev Subtracts y from x, assuming they are both fixed point with 18 decimals.\\n    function subd(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x.sub(y);\\n    }\\n\\n    /// @dev Multiplies x and y, assuming they are both fixed point with 18 digits.\\n    function muld(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return muld(x, y, 18);\\n    }\\n\\n    /// @dev Multiplies x and y, assuming they are both fixed point with `decimals` digits.\\n    function muld(\\n        uint256 x,\\n        uint256 y,\\n        uint8 decimals\\n    ) internal pure returns (uint256) {\\n        return x.mul(y).div(unit(decimals));\\n    }\\n\\n    /// @dev Divides x between y, assuming they are both fixed point with 18 digits.\\n    function divd(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return divd(x, y, 18);\\n    }\\n\\n    /// @dev Divides x between y, assuming they are both fixed point with `decimals` digits.\\n    function divd(\\n        uint256 x,\\n        uint256 y,\\n        uint8 decimals\\n    ) internal pure returns (uint256) {\\n        return x.mul(unit(decimals)).div(y);\\n    }\\n}\\n\",\"keccak256\":\"0x4879526465b70a7166efb7b32359e2713579ace533c766cc215c8e717ba8da5e\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/IfnxFiOwnableUpgrade.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\n\\nimport {ContextUpgradeSafe} from \\\"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\\\";\\n\\n// copy from openzeppelin Ownable, only modify how the owner transfer\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract IfnxFiOwnableUpgrade is ContextUpgradeSafe {\\n    address private _owner;\\n    address private _candidate;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function candidate() public view returns (address) {\\n        return _candidate;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"IfnxFiOwnableUpgrade: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Set ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function setOwner(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"IfnxFiOwnableUpgrade: zero address\\\");\\n        require(newOwner != _owner, \\\"IfnxFiOwnableUpgrade: same as original\\\");\\n        require(newOwner != _candidate, \\\"IfnxFiOwnableUpgrade: same as candidate\\\");\\n        _candidate = newOwner;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`_candidate`).\\n     * Can only be called by the new owner.\\n     */\\n    function updateOwner() public {\\n        require(_candidate != address(0), \\\"IfnxFiOwnableUpgrade: candidate is zero address\\\");\\n        require(_candidate == _msgSender(), \\\"IfnxFiOwnableUpgrade: not the new owner\\\");\\n\\n        emit OwnershipTransferred(_owner, _candidate);\\n        _owner = _candidate;\\n        _candidate = address(0);\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xd04de8ce5b77f84da11af5b08c942c1774813b4ebc14fccedfd81d918b90ab88\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/MixedDecimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\n\\nimport {Decimal} from \\\"./Decimal.sol\\\";\\nimport {SignedDecimal} from \\\"./SignedDecimal.sol\\\";\\nimport {SignedSafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\\\";\\n\\n/// @dev To handle a signedDecimal add/sub/mul/div a decimal and provide convert decimal to signedDecimal helper\\nlibrary MixedDecimal {\\n    using SignedDecimal for SignedDecimal.signedDecimal;\\n    using SignedSafeMath for int256;\\n\\n    uint256 private constant _INT256_MAX = 2**255 - 1;\\n    string private constant ERROR_NON_CONVERTIBLE =\\n        \\\"MixedDecimal: uint value is bigger than _INT256_MAX\\\";\\n\\n    modifier convertible(Decimal.decimal memory x) {\\n        require(_INT256_MAX >= x.d, ERROR_NON_CONVERTIBLE);\\n        _;\\n    }\\n\\n    function fromDecimal(Decimal.decimal memory x)\\n        internal\\n        pure\\n        convertible(x)\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        return SignedDecimal.signedDecimal(int256(x.d));\\n    }\\n\\n    function toUint(SignedDecimal.signedDecimal memory x) internal pure returns (uint256) {\\n        return x.abs().d;\\n    }\\n\\n    /// @dev add SignedDecimal.signedDecimal and Decimal.decimal, using SignedSafeMath directly\\n    function addD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\\n        internal\\n        pure\\n        convertible(y)\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        SignedDecimal.signedDecimal memory t;\\n        t.d = x.d.add(int256(y.d));\\n        return t;\\n    }\\n\\n    /// @dev subtract SignedDecimal.signedDecimal by Decimal.decimal, using SignedSafeMath directly\\n    function subD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\\n        internal\\n        pure\\n        convertible(y)\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        SignedDecimal.signedDecimal memory t;\\n        t.d = x.d.sub(int256(y.d));\\n        return t;\\n    }\\n\\n    /// @dev multiple a SignedDecimal.signedDecimal by Decimal.decimal\\n    function mulD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\\n        internal\\n        pure\\n        convertible(y)\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        SignedDecimal.signedDecimal memory t;\\n        t = x.mulD(fromDecimal(y));\\n        return t;\\n    }\\n\\n    /// @dev multiple a SignedDecimal.signedDecimal by a uint256\\n    function mulScalar(SignedDecimal.signedDecimal memory x, uint256 y)\\n        internal\\n        pure\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        require(_INT256_MAX >= y, ERROR_NON_CONVERTIBLE);\\n        SignedDecimal.signedDecimal memory t;\\n        t = x.mulScalar(int256(y));\\n        return t;\\n    }\\n\\n    /// @dev divide a SignedDecimal.signedDecimal by a Decimal.decimal\\n    function divD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\\n        internal\\n        pure\\n        convertible(y)\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        SignedDecimal.signedDecimal memory t;\\n        t = x.divD(fromDecimal(y));\\n        return t;\\n    }\\n\\n    /// @dev divide a SignedDecimal.signedDecimal by a uint256\\n    function divScalar(SignedDecimal.signedDecimal memory x, uint256 y)\\n        internal\\n        pure\\n        returns (SignedDecimal.signedDecimal memory)\\n    {\\n        require(_INT256_MAX >= y, ERROR_NON_CONVERTIBLE);\\n        SignedDecimal.signedDecimal memory t;\\n        t = x.divScalar(int256(y));\\n        return t;\\n    }\\n}\\n\",\"keccak256\":\"0xd761a7aee6c51a11d4e1575494085f253a65e6b86db58ec26c80766fed987de0\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/SignedDecimal.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\n\\nimport {SignedSafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\\\";\\nimport {SignedDecimalMath} from \\\"./SignedDecimalMath.sol\\\";\\nimport {Decimal} from \\\"./Decimal.sol\\\";\\n\\nlibrary SignedDecimal {\\n    using SignedDecimalMath for int256;\\n    using SignedSafeMath for int256;\\n\\n    struct signedDecimal {\\n        int256 d;\\n    }\\n\\n    function zero() internal pure returns (signedDecimal memory) {\\n        return signedDecimal(0);\\n    }\\n\\n    function toInt(signedDecimal memory x) internal pure returns (int256) {\\n        return x.d;\\n    }\\n\\n    function isNegative(signedDecimal memory x) internal pure returns (bool) {\\n        if (x.d < 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function abs(signedDecimal memory x) internal pure returns (Decimal.decimal memory) {\\n        Decimal.decimal memory t;\\n        if (x.d < 0) {\\n            t.d = uint256(0 - x.d);\\n        } else {\\n            t.d = uint256(x.d);\\n        }\\n        return t;\\n    }\\n\\n    /// @dev add two decimals\\n    function addD(signedDecimal memory x, signedDecimal memory y)\\n        internal\\n        pure\\n        returns (signedDecimal memory)\\n    {\\n        signedDecimal memory t;\\n        t.d = x.d.add(y.d);\\n        return t;\\n    }\\n\\n    /// @dev subtract two decimals\\n    function subD(signedDecimal memory x, signedDecimal memory y)\\n        internal\\n        pure\\n        returns (signedDecimal memory)\\n    {\\n        signedDecimal memory t;\\n        t.d = x.d.sub(y.d);\\n        return t;\\n    }\\n\\n    /// @dev multiple two decimals\\n    function mulD(signedDecimal memory x, signedDecimal memory y)\\n        internal\\n        pure\\n        returns (signedDecimal memory)\\n    {\\n        signedDecimal memory t;\\n        t.d = x.d.muld(y.d);\\n        return t;\\n    }\\n\\n    /// @dev multiple a signedDecimal by a int256\\n    function mulScalar(signedDecimal memory x, int256 y)\\n        internal\\n        pure\\n        returns (signedDecimal memory)\\n    {\\n        signedDecimal memory t;\\n        t.d = x.d.mul(y);\\n        return t;\\n    }\\n\\n    /// @dev divide two decimals\\n    function divD(signedDecimal memory x, signedDecimal memory y)\\n        internal\\n        pure\\n        returns (signedDecimal memory)\\n    {\\n        signedDecimal memory t;\\n        t.d = x.d.divd(y.d);\\n        return t;\\n    }\\n\\n    /// @dev divide a signedDecimal by a int256\\n    function divScalar(signedDecimal memory x, int256 y)\\n        internal\\n        pure\\n        returns (signedDecimal memory)\\n    {\\n        signedDecimal memory t;\\n        t.d = x.d.div(y);\\n        return t;\\n    }\\n}\\n\",\"keccak256\":\"0xf5a874997ac59e59cc1176149e159a095977b145232507e8faa7bd0933d6e7f7\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/SignedDecimalMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.9;\\n\\nimport {SignedSafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\\\";\\n\\n/// @dev Implements simple signed fixed point math add, sub, mul and div operations.\\nlibrary SignedDecimalMath {\\n    using SignedSafeMath for int256;\\n\\n    /// @dev Returns 1 in the fixed point representation, with `decimals` decimals.\\n    function unit(uint8 decimals) internal pure returns (int256) {\\n        return int256(10**uint256(decimals));\\n    }\\n\\n    /// @dev Adds x and y, assuming they are both fixed point with 18 decimals.\\n    function addd(int256 x, int256 y) internal pure returns (int256) {\\n        return x.add(y);\\n    }\\n\\n    /// @dev Subtracts y from x, assuming they are both fixed point with 18 decimals.\\n    function subd(int256 x, int256 y) internal pure returns (int256) {\\n        return x.sub(y);\\n    }\\n\\n    /// @dev Multiplies x and y, assuming they are both fixed point with 18 digits.\\n    function muld(int256 x, int256 y) internal pure returns (int256) {\\n        return muld(x, y, 18);\\n    }\\n\\n    /// @dev Multiplies x and y, assuming they are both fixed point with `decimals` digits.\\n    function muld(\\n        int256 x,\\n        int256 y,\\n        uint8 decimals\\n    ) internal pure returns (int256) {\\n        return x.mul(y).div(unit(decimals));\\n    }\\n\\n    /// @dev Divides x between y, assuming they are both fixed point with 18 digits.\\n    function divd(int256 x, int256 y) internal pure returns (int256) {\\n        return divd(x, y, 18);\\n    }\\n\\n    /// @dev Divides x between y, assuming they are both fixed point with `decimals` digits.\\n    function divd(\\n        int256 x,\\n        int256 y,\\n        uint8 decimals\\n    ) internal pure returns (int256) {\\n        return x.mul(unit(decimals)).div(y);\\n    }\\n}\\n\",\"keccak256\":\"0x5fdb8310e8a1d7f2770179ff12515c0cfbbf83474a263ce316f4a4a9a7dda8b8\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610863806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063e7f9871e14610030575b600080fd5b61004361003e3660046105c7565b610059565b6040516100509190610733565b60405180910390f35b61006161053e565b600082905060006060826001600160a01b031663fdf262b76040518163ffffffff1660e01b815260040160206040518083038186803b1580156100a357600080fd5b505afa1580156100b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100db9190610602565b60408051600481526024810182526020810180516001600160e01b03166395d89b4160e01b17905290516001600160a01b03929092169161011c9190610717565b600060405180830381855afa9150503d8060008114610157576040519150601f19603f3d011682016040523d82523d6000602084013e61015c565b606091505b509150915061016961058f565b61017161058f565b846001600160a01b03166359bf5d396040518163ffffffff1660e01b8152600401604080518083038186803b1580156101a957600080fd5b505afa1580156101bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e191906106aa565b915091506000856001600160a01b03166358a4c3dc6040518163ffffffff1660e01b815260040160206040518083038186803b15801561022057600080fd5b505afa158015610234573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025891906105ea565b905060405180610100016040528061026f8561043d565b815260200161027d8461043d565b8152602001876001600160a01b0316638f40d9326040518163ffffffff1660e01b815260040160206040518083038186803b1580156102bb57600080fd5b505afa1580156102cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f391906105ea565b8152602001876001600160a01b03166374d7c62b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561033157600080fd5b505afa158015610345573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036991906105ea565b815260200186610388576040518060200160405280600081525061039c565b8580602001905181019061039c919061061e565b81526020016103aa83610441565b8152602001828152602001876001600160a01b031663741bef1a6040518163ffffffff1660e01b815260040160206040518083038186803b1580156103ee57600080fd5b505afa158015610402573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104269190610602565b6001600160a01b0316905298975050505050505050565b5190565b606060005b60208160ff161080156104745750828160ff166020811061046357fe5b1a60f81b6001600160f81b03191615155b1561048157600101610446565b60608160ff1667ffffffffffffffff8111801561049d57600080fd5b506040519080825280601f01601f1916602001820160405280156104c8576020820181803683370190505b50905060005b6020811080156104f657508481602081106104e557fe5b1a60f81b6001600160f81b03191615155b156105365784816020811061050757fe5b1a60f81b82828151811061051757fe5b60200101906001600160f81b031916908160001a9053506001016104ce565b509392505050565b6040518061010001604052806000815260200160008152602001600081526020016000815260200160608152602001606081526020016000801916815260200160006001600160a01b031681525090565b6040518060200160405280600081525090565b6000602082840312156105b3578081fd5b6105bd60206107be565b9151825250919050565b6000602082840312156105d8578081fd5b81356105e381610815565b9392505050565b6000602082840312156105fb578081fd5b5051919050565b600060208284031215610613578081fd5b81516105e381610815565b60006020828403121561062f578081fd5b815167ffffffffffffffff80821115610646578283fd5b81840185601f820112610657578384fd5b8051925081831115610667578384fd5b61067a601f8401601f19166020016107be565b9150828252856020848301011115610690578384fd5b6106a18360208401602084016107e5565b50949350505050565b600080604083850312156106bc578081fd5b6106c684846105a2565b91506106d584602085016105a2565b90509250929050565b6001600160a01b03169052565b600081518084526107038160208601602086016107e5565b601f01601f19169290920160200192915050565b600082516107298184602087016107e5565b9190910192915050565b6000602082528251602083015260208301516040830152604083015160608301526060830151608083015260808301516101008060a085015261077a6101208501836106eb565b60a0860151858203601f190160c0870152925061079781846106eb565b60c087015160e087015260e087015193506107b4838701856106de565b9695505050505050565b60405181810167ffffffffffffffff811182821017156107dd57600080fd5b604052919050565b60005b838110156108005781810151838201526020016107e8565b8381111561080f576000848401525b50505050565b6001600160a01b038116811461082a57600080fd5b5056fea2646970667358221220732d83c563567e94c2a60300851cb81e789b9e88f1e6eeed54afb0b87c46401764736f6c63430006090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063e7f9871e14610030575b600080fd5b61004361003e3660046105c7565b610059565b6040516100509190610733565b60405180910390f35b61006161053e565b600082905060006060826001600160a01b031663fdf262b76040518163ffffffff1660e01b815260040160206040518083038186803b1580156100a357600080fd5b505afa1580156100b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100db9190610602565b60408051600481526024810182526020810180516001600160e01b03166395d89b4160e01b17905290516001600160a01b03929092169161011c9190610717565b600060405180830381855afa9150503d8060008114610157576040519150601f19603f3d011682016040523d82523d6000602084013e61015c565b606091505b509150915061016961058f565b61017161058f565b846001600160a01b03166359bf5d396040518163ffffffff1660e01b8152600401604080518083038186803b1580156101a957600080fd5b505afa1580156101bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e191906106aa565b915091506000856001600160a01b03166358a4c3dc6040518163ffffffff1660e01b815260040160206040518083038186803b15801561022057600080fd5b505afa158015610234573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061025891906105ea565b905060405180610100016040528061026f8561043d565b815260200161027d8461043d565b8152602001876001600160a01b0316638f40d9326040518163ffffffff1660e01b815260040160206040518083038186803b1580156102bb57600080fd5b505afa1580156102cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f391906105ea565b8152602001876001600160a01b03166374d7c62b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561033157600080fd5b505afa158015610345573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036991906105ea565b815260200186610388576040518060200160405280600081525061039c565b8580602001905181019061039c919061061e565b81526020016103aa83610441565b8152602001828152602001876001600160a01b031663741bef1a6040518163ffffffff1660e01b815260040160206040518083038186803b1580156103ee57600080fd5b505afa158015610402573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104269190610602565b6001600160a01b0316905298975050505050505050565b5190565b606060005b60208160ff161080156104745750828160ff166020811061046357fe5b1a60f81b6001600160f81b03191615155b1561048157600101610446565b60608160ff1667ffffffffffffffff8111801561049d57600080fd5b506040519080825280601f01601f1916602001820160405280156104c8576020820181803683370190505b50905060005b6020811080156104f657508481602081106104e557fe5b1a60f81b6001600160f81b03191615155b156105365784816020811061050757fe5b1a60f81b82828151811061051757fe5b60200101906001600160f81b031916908160001a9053506001016104ce565b509392505050565b6040518061010001604052806000815260200160008152602001600081526020016000815260200160608152602001606081526020016000801916815260200160006001600160a01b031681525090565b6040518060200160405280600081525090565b6000602082840312156105b3578081fd5b6105bd60206107be565b9151825250919050565b6000602082840312156105d8578081fd5b81356105e381610815565b9392505050565b6000602082840312156105fb578081fd5b5051919050565b600060208284031215610613578081fd5b81516105e381610815565b60006020828403121561062f578081fd5b815167ffffffffffffffff80821115610646578283fd5b81840185601f820112610657578384fd5b8051925081831115610667578384fd5b61067a601f8401601f19166020016107be565b9150828252856020848301011115610690578384fd5b6106a18360208401602084016107e5565b50949350505050565b600080604083850312156106bc578081fd5b6106c684846105a2565b91506106d584602085016105a2565b90509250929050565b6001600160a01b03169052565b600081518084526107038160208601602086016107e5565b601f01601f19169290920160200192915050565b600082516107298184602087016107e5565b9190910192915050565b6000602082528251602083015260208301516040830152604083015160608301526060830151608083015260808301516101008060a085015261077a6101208501836106eb565b60a0860151858203601f190160c0870152925061079781846106eb565b60c087015160e087015260e087015193506107b4838701856106de565b9695505050505050565b60405181810167ffffffffffffffff811182821017156107dd57600080fd5b604052919050565b60005b838110156108005781810151838201526020016107e8565b8381111561080f576000848401525b50505050565b6001600160a01b038116811461082a57600080fd5b5056fea2646970667358221220732d83c563567e94c2a60300851cb81e789b9e88f1e6eeed54afb0b87c46401764736f6c63430006090033",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}