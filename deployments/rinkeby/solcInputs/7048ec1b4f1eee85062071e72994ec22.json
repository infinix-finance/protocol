{
  "language": "Solidity",
  "sources": {
    "contracts/Amm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { BlockContext } from \"./utils/BlockContext.sol\";\nimport { IPriceFeed } from \"./interface/IPriceFeed.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport { Decimal } from \"./utils/Decimal.sol\";\nimport { SignedDecimal } from \"./utils/SignedDecimal.sol\";\nimport { MixedDecimal } from \"./utils/MixedDecimal.sol\";\nimport { IfnxFiOwnableUpgrade } from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport { IAmm } from \"./interface/IAmm.sol\";\n\ncontract Amm is IAmm, IfnxFiOwnableUpgrade, BlockContext {\n    using SafeMath for uint256;\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    //\n    // CONSTANT\n    //\n    // because position decimal rounding error,\n    // if the position size is less than IGNORABLE_DIGIT_FOR_SHUTDOWN, it's equal size is 0\n    uint256 private constant IGNORABLE_DIGIT_FOR_SHUTDOWN = 100;\n\n    // a margin to prevent from rounding when calc liquidity multiplier limit\n    uint256 private constant MARGIN_FOR_LIQUIDITY_MIGRATION_ROUNDING = 1e9;\n\n    //\n    // EVENTS\n    //\n    event SwapInput(Dir dir, uint256 quoteAssetAmount, uint256 baseAssetAmount);\n    event SwapOutput(Dir dir, uint256 quoteAssetAmount, uint256 baseAssetAmount);\n    event FundingRateUpdated(int256 rate, uint256 underlyingPrice);\n    event ReserveSnapshotted(uint256 quoteAssetReserve, uint256 baseAssetReserve, uint256 timestamp);\n    event LiquidityChanged(uint256 quoteReserve, uint256 baseReserve, int256 cumulativeNotional);\n    event CapChanged(uint256 maxHoldingBaseAsset, uint256 openInterestNotionalCap);\n    event Shutdown(uint256 settlementPrice);\n    event PriceFeedUpdated(address priceFeed);\n\n    //\n    // MODIFIERS\n    //\n    modifier onlyOpen() {\n        require(open, \"amm was closed\");\n        _;\n    }\n\n    modifier onlyCounterParty() {\n        require(counterParty == _msgSender(), \"caller is not counterParty\");\n        _;\n    }\n\n    //\n    // enum and struct\n    //\n    struct ReserveSnapshot {\n        Decimal.decimal quoteAssetReserve;\n        Decimal.decimal baseAssetReserve;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n\n    // internal usage\n    enum QuoteAssetDir { QUOTE_IN, QUOTE_OUT }\n    // internal usage\n    enum TwapCalcOption { RESERVE_ASSET, INPUT_ASSET }\n\n    // To record current base/quote asset to calculate TWAP\n\n    struct TwapInputAsset {\n        Dir dir;\n        Decimal.decimal assetAmount;\n        QuoteAssetDir inOrOut;\n    }\n\n    struct TwapPriceCalcParams {\n        TwapCalcOption opt;\n        uint256 snapshotIndex;\n        TwapInputAsset asset;\n    }\n\n    //\n    // Constant\n    //\n    // 10%\n    uint256 public constant MAX_ORACLE_SPREAD_RATIO = 1e17;\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n\n    // DEPRECATED\n    // update during every swap and calculate total amm pnl per funding period\n    SignedDecimal.signedDecimal private baseAssetDeltaThisFundingPeriod;\n\n    // update during every swap and used when shutting amm down. it's trader's total base asset size\n    SignedDecimal.signedDecimal public totalPositionSize;\n\n    // latest funding rate = ((twap market price - twap oracle price) / twap oracle price) / 24\n    SignedDecimal.signedDecimal public fundingRate;\n\n    SignedDecimal.signedDecimal private cumulativeNotional;\n\n    Decimal.decimal private settlementPrice;\n    Decimal.decimal public tradeLimitRatio;\n    Decimal.decimal public quoteAssetReserve;\n    Decimal.decimal public baseAssetReserve;\n    Decimal.decimal public fluctuationLimitRatio;\n\n    // owner can update\n    Decimal.decimal public tollRatio;\n    Decimal.decimal public spreadRatio;\n    Decimal.decimal public tollAmount;\n    Decimal.decimal private maxHoldingBaseAsset;\n    Decimal.decimal private openInterestNotionalCap;\n\n    // init cumulativePositionMultiplier is 1, will be updated every time when amm reserve increase/decrease\n    Decimal.decimal private cumulativePositionMultiplier;\n\n    // snapshot of amm reserve when change liquidity's invariant\n    LiquidityChangedSnapshot[] private liquidityChangedSnapshots;\n\n    uint256 public spotPriceTwapInterval;\n    uint256 public fundingPeriod;\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n    bytes32 public priceFeedKey;\n    ReserveSnapshot[] public reserveSnapshots;\n\n    address private counterParty;\n    address public globalShutdown;\n    IERC20 public override quoteAsset;\n    IPriceFeed public priceFeed;\n    bool public override open;\n    uint256[50] private __gap;\n\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n\n    //\n    // FUNCTIONS\n    //\n    function initialize(\n        uint256 _quoteAssetReserve,\n        uint256 _baseAssetReserve,\n        uint256 _tradeLimitRatio,\n        uint256 _fundingPeriod,\n        IPriceFeed _priceFeed,\n        bytes32 _priceFeedKey,\n        address _quoteAsset,\n        uint256 _fluctuationLimitRatio,\n        uint256 _tollRatio,\n        uint256 _spreadRatio\n    ) public initializer {\n        require(\n            _quoteAssetReserve != 0 &&\n                _tradeLimitRatio != 0 &&\n                _baseAssetReserve != 0 &&\n                _fundingPeriod != 0 &&\n                address(_priceFeed) != address(0) &&\n                _quoteAsset != address(0),\n            \"invalid input\"\n        );\n        __Ownable_init();\n\n        quoteAssetReserve = Decimal.decimal(_quoteAssetReserve);\n        baseAssetReserve = Decimal.decimal(_baseAssetReserve);\n        tradeLimitRatio = Decimal.decimal(_tradeLimitRatio);\n        tollRatio = Decimal.decimal(_tollRatio);\n        spreadRatio = Decimal.decimal(_spreadRatio);\n        fluctuationLimitRatio = Decimal.decimal(_fluctuationLimitRatio);\n        fundingPeriod = _fundingPeriod;\n        fundingBufferPeriod = _fundingPeriod.div(2);\n        spotPriceTwapInterval = 1 hours;\n        priceFeedKey = _priceFeedKey;\n        quoteAsset = IERC20(_quoteAsset);\n        priceFeed = _priceFeed;\n        cumulativePositionMultiplier = Decimal.one();\n        liquidityChangedSnapshots.push(\n            LiquidityChangedSnapshot({\n                cumulativeNotional: SignedDecimal.zero(),\n                baseAssetReserve: baseAssetReserve,\n                quoteAssetReserve: quoteAssetReserve,\n                totalPositionSize: SignedDecimal.zero()\n            })\n        );\n        reserveSnapshots.push(ReserveSnapshot(quoteAssetReserve, baseAssetReserve, _blockTimestamp(), _blockNumber()));\n        emit ReserveSnapshotted(quoteAssetReserve.toUint(), baseAssetReserve.toUint(), _blockTimestamp());\n    }\n\n    /**\n     * @notice Swap your quote asset to base asset, the impact of the price MUST be less than `fluctuationLimitRatio`\n     * @dev Only clearingHouse can call this function\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short\n     * @param _quoteAssetAmount quote asset amount\n     * @param _baseAssetAmountLimit minimum base asset amount expected to get to prevent front running\n     * @param _canOverFluctuationLimit if tx can go over fluctuation limit once; for partial liquidation\n     * @return base asset amount\n     */\n    function swapInput(\n        Dir _dirOfQuote,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _baseAssetAmountLimit,\n        bool _canOverFluctuationLimit\n    ) external override onlyOpen onlyCounterParty returns (Decimal.decimal memory) {\n        if (_quoteAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n        if (_dirOfQuote == Dir.REMOVE_FROM_AMM) {\n            require(\n                quoteAssetReserve.mulD(tradeLimitRatio).toUint() >= _quoteAssetAmount.toUint(),\n                \"over trading limit\"\n            );\n        }\n\n        Decimal.decimal memory baseAssetAmount = getInputPrice(_dirOfQuote, _quoteAssetAmount);\n        // If LONG, exchanged base amount should be more than _baseAssetAmountLimit,\n        // otherwise(SHORT), exchanged base amount should be less than _baseAssetAmountLimit.\n        // In SHORT case, more position means more debt so should not be larger than _baseAssetAmountLimit\n        if (_baseAssetAmountLimit.toUint() != 0) {\n            if (_dirOfQuote == Dir.ADD_TO_AMM) {\n                require(baseAssetAmount.toUint() >= _baseAssetAmountLimit.toUint(), \"Less than minimal base token\");\n            } else {\n                require(baseAssetAmount.toUint() <= _baseAssetAmountLimit.toUint(), \"More than maximal base token\");\n            }\n        }\n\n        updateReserve(_dirOfQuote, _quoteAssetAmount, baseAssetAmount, _canOverFluctuationLimit);\n        emit SwapInput(_dirOfQuote, _quoteAssetAmount.toUint(), baseAssetAmount.toUint());\n        return baseAssetAmount;\n    }\n\n    /**\n     * @notice swap your base asset to quote asset; NOTE it is only used during close/liquidate positions so it always allows going over fluctuation limit\n     * @dev only clearingHouse can call this function\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from swapInput\n     * @param _baseAssetAmount base asset amount\n     * @param _quoteAssetAmountLimit limit of quote asset amount; for slippage protection\n     * @return quote asset amount\n     */\n    function swapOutput(\n        Dir _dirOfBase,\n        Decimal.decimal calldata _baseAssetAmount,\n        Decimal.decimal calldata _quoteAssetAmountLimit\n    ) external override onlyOpen onlyCounterParty returns (Decimal.decimal memory) {\n        return implSwapOutput(_dirOfBase, _baseAssetAmount, _quoteAssetAmountLimit);\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     * @return premium fraction of this period in 18 digits\n     */\n    function settleFunding() external override onlyOpen onlyCounterParty returns (SignedDecimal.signedDecimal memory) {\n        require(_blockTimestamp() >= nextFundingTime, \"settle funding too early\");\n\n        // premium = twapMarketPrice - vwapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        Decimal.decimal memory underlyingPrice = getUnderlyingPrice();\n        SignedDecimal.signedDecimal memory premium =\n            MixedDecimal.fromDecimal(getTwapPrice(spotPriceTwapInterval)).subD(underlyingPrice);\n        SignedDecimal.signedDecimal memory premiumFraction = premium.mulScalar(fundingPeriod).divScalar(int256(1 days));\n\n        // update funding rate = premiumFraction / twapIndexPrice\n        updateFundingRate(premiumFraction, underlyingPrice);\n\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = _blockTimestamp().add(fundingBufferPeriod);\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = nextFundingTime.add(fundingPeriod).div(1 hours).mul(1 hours);\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n\n        // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\n        // reset funding related states\n        baseAssetDeltaThisFundingPeriod = SignedDecimal.zero();\n\n        return premiumFraction;\n    }\n\n    function calcBaseAssetAfterLiquidityMigration(\n        SignedDecimal.signedDecimal memory _baseAssetAmount,\n        Decimal.decimal memory _fromQuoteReserve,\n        Decimal.decimal memory _fromBaseReserve\n    ) public view override returns (SignedDecimal.signedDecimal memory) {\n        if (_baseAssetAmount.toUint() == 0) {\n            return _baseAssetAmount;\n        }\n\n        bool isPositiveValue = _baseAssetAmount.toInt() > 0 ? true : false;\n\n        // measure the trader position's notional value on the old curve\n        // (by simulating closing the position)\n        Decimal.decimal memory posNotional =\n            getOutputPriceWithReserves(\n                isPositiveValue ? Dir.ADD_TO_AMM : Dir.REMOVE_FROM_AMM,\n                _baseAssetAmount.abs(),\n                _fromQuoteReserve,\n                _fromBaseReserve\n            );\n\n        // calculate and apply the required size on the new curve\n        SignedDecimal.signedDecimal memory newBaseAsset =\n            MixedDecimal.fromDecimal(\n                getInputPrice(isPositiveValue ? Dir.REMOVE_FROM_AMM : Dir.ADD_TO_AMM, posNotional)\n            );\n        return newBaseAsset.mulScalar(isPositiveValue ? 1 : int256(-1));\n    }\n\n    /**\n     * @notice shutdown amm,\n     * @dev only `globalShutdown` or owner can call this function\n     * The price calculation is in `globalShutdown`.\n     */\n    function shutdown() external override {\n        require(_msgSender() == owner() || _msgSender() == globalShutdown, \"not owner nor globalShutdown\");\n        implShutdown();\n    }\n\n    /**\n     * @notice set counter party\n     * @dev only owner can call this function\n     * @param _counterParty address of counter party\n     */\n    function setCounterParty(address _counterParty) external onlyOwner {\n        counterParty = _counterParty;\n    }\n\n    /**\n     * @notice set `globalShutdown`\n     * @dev only owner can call this function\n     * @param _globalShutdown address of `globalShutdown`\n     */\n    function setGlobalShutdown(address _globalShutdown) external onlyOwner {\n        globalShutdown = _globalShutdown;\n    }\n\n    /**\n     * @notice set fluctuation limit rate. Default value is `1 / max leverage`\n     * @dev only owner can call this function\n     * @param _fluctuationLimitRatio fluctuation limit rate in 18 digits, 0 means skip the checking\n     */\n    function setFluctuationLimitRatio(Decimal.decimal memory _fluctuationLimitRatio) public onlyOwner {\n        fluctuationLimitRatio = _fluctuationLimitRatio;\n    }\n\n    /**\n     * @notice set time interval for twap calculation, default is 1 hour\n     * @dev only owner can call this function\n     * @param _interval time interval in seconds\n     */\n    function setSpotPriceTwapInterval(uint256 _interval) external onlyOwner {\n        require(_interval != 0, \"can not set interval to 0\");\n        spotPriceTwapInterval = _interval;\n    }\n\n    /**\n     * @notice set `open` flag. Amm is open to trade if `open` is true. Default is false.\n     * @dev only owner can call this function\n     * @param _open open to trade is true, otherwise is false.\n     */\n    function setOpen(bool _open) external onlyOwner {\n        if (open == _open) return;\n\n        open = _open;\n        if (_open) {\n            nextFundingTime = _blockTimestamp().add(fundingPeriod).div(1 hours).mul(1 hours);\n        }\n    }\n\n    /**\n     * @notice set new toll ratio\n     * @dev only owner can call\n     * @param _tollRatio new toll ratio in 18 digits\n     */\n    function setTollRatio(Decimal.decimal memory _tollRatio) public onlyOwner {\n        tollRatio = _tollRatio;\n    }\n\n    /**\n     * @notice set new spread ratio\n     * @dev only owner can call\n     * @param _spreadRatio new toll spread in 18 digits\n     */\n    function setSpreadRatio(Decimal.decimal memory _spreadRatio) public onlyOwner {\n        spreadRatio = _spreadRatio;\n    }\n\n    /**\n     * @notice set new cap during guarded period, which is max position size that traders can hold\n     * @dev only owner can call. assume this will be removes soon once the guarded period has ended. must be set before opening amm\n     * @param _maxHoldingBaseAsset max position size that traders can hold in 18 digits\n     * @param _openInterestNotionalCap open interest cap, denominated in quoteToken\n     */\n    function setCap(Decimal.decimal memory _maxHoldingBaseAsset, Decimal.decimal memory _openInterestNotionalCap)\n        public\n        onlyOwner\n    {\n        maxHoldingBaseAsset = _maxHoldingBaseAsset;\n        openInterestNotionalCap = _openInterestNotionalCap;\n        emit CapChanged(maxHoldingBaseAsset.toUint(), openInterestNotionalCap.toUint());\n    }\n\n    /**\n     * @notice set priceFee address\n     * @dev only owner can call\n     * @param _priceFeed new price feed for this AMM\n     */\n    function setPriceFeed(IPriceFeed _priceFeed) public onlyOwner {\n        require(address(_priceFeed) != address(0), \"invalid PriceFeed address\");\n        priceFeed = _priceFeed;\n        emit PriceFeedUpdated(address(priceFeed));\n    }\n\n    //\n    // VIEW FUNCTIONS\n    //\n\n    function isOverFluctuationLimit(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\n        external\n        view\n        override\n        returns (bool)\n    {\n        // Skip the check if the limit is 0\n        if (fluctuationLimitRatio.toUint() == 0) {\n            return false;\n        }\n\n        (Decimal.decimal memory upperLimit, Decimal.decimal memory lowerLimit) = getPriceBoundariesOfLastBlock();\n\n        Decimal.decimal memory quoteAssetExchanged = getOutputPrice(_dirOfBase, _baseAssetAmount);\n        Decimal.decimal memory price =\n            (_dirOfBase == Dir.REMOVE_FROM_AMM)\n                ? quoteAssetReserve.addD(quoteAssetExchanged).divD(baseAssetReserve.subD(_baseAssetAmount))\n                : quoteAssetReserve.subD(quoteAssetExchanged).divD(baseAssetReserve.addD(_baseAssetAmount));\n\n        if (price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @notice get input twap amount.\n     * returns how many base asset you will get with the input quote amount based on twap price.\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short.\n     * @param _quoteAssetAmount quote asset amount\n     * @return base asset amount\n     */\n    function getInputTwap(Dir _dirOfQuote, Decimal.decimal memory _quoteAssetAmount)\n        public\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return implGetInputAssetTwapPrice(_dirOfQuote, _quoteAssetAmount, QuoteAssetDir.QUOTE_IN, 15 minutes);\n    }\n\n    /**\n     * @notice get output twap amount.\n     * return how many quote asset you will get with the input base amount on twap price.\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from `getInputTwap`.\n     * @param _baseAssetAmount base asset amount\n     * @return quote asset amount\n     */\n    function getOutputTwap(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\n        public\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return implGetInputAssetTwapPrice(_dirOfBase, _baseAssetAmount, QuoteAssetDir.QUOTE_OUT, 15 minutes);\n    }\n\n    /**\n     * @notice get input amount. returns how many base asset you will get with the input quote amount.\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short.\n     * @param _quoteAssetAmount quote asset amount\n     * @return base asset amount\n     */\n    function getInputPrice(Dir _dirOfQuote, Decimal.decimal memory _quoteAssetAmount)\n        public\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return getInputPriceWithReserves(_dirOfQuote, _quoteAssetAmount, quoteAssetReserve, baseAssetReserve);\n    }\n\n    /**\n     * @notice get output price. return how many quote asset you will get with the input base amount\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from `getInput`.\n     * @param _baseAssetAmount base asset amount\n     * @return quote asset amount\n     */\n    function getOutputPrice(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\n        public\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return getOutputPriceWithReserves(_dirOfBase, _baseAssetAmount, quoteAssetReserve, baseAssetReserve);\n    }\n\n    /**\n     * @notice get underlying price provided by oracle\n     * @return underlying price\n     */\n    function getUnderlyingPrice() public view override returns (Decimal.decimal memory) {\n        return Decimal.decimal(priceFeed.getPrice(priceFeedKey));\n    }\n\n\n    /**\n     * @notice get spot price based on current quote/base asset reserve.\n     * @return spot price\n     */\n    function getSpotPrice() public view override returns (Decimal.decimal memory) {\n        return quoteAssetReserve.divD(baseAssetReserve);\n    }\n\n    /**\n     * @notice get twap price\n     */\n    function getTwapPrice(uint256 _intervalInSeconds) public view returns (Decimal.decimal memory) {\n        return implGetReserveTwapPrice(_intervalInSeconds);\n    }\n\n    /**\n     * @notice get current quote/base asset reserve.\n     * @return (quote asset reserve, base asset reserve)\n     */\n    function getReserve() external view returns (Decimal.decimal memory, Decimal.decimal memory) {\n        return (quoteAssetReserve, baseAssetReserve);\n    }\n\n    function getSnapshotLen() external view returns (uint256) {\n        return reserveSnapshots.length;\n    }\n\n    function getLiquidityHistoryLength() external view override returns (uint256) {\n        return liquidityChangedSnapshots.length;\n    }\n\n    function getCumulativeNotional() external view override returns (SignedDecimal.signedDecimal memory) {\n        return cumulativeNotional;\n    }\n\n    function getLatestLiquidityChangedSnapshots() public view returns (LiquidityChangedSnapshot memory) {\n        return liquidityChangedSnapshots[liquidityChangedSnapshots.length.sub(1)];\n    }\n\n    function getLiquidityChangedSnapshots(uint256 i) external view override returns (LiquidityChangedSnapshot memory) {\n        require(i < liquidityChangedSnapshots.length, \"incorrect index\");\n        return liquidityChangedSnapshots[i];\n    }\n\n    function getSettlementPrice() external view override returns (Decimal.decimal memory) {\n        return settlementPrice;\n    }\n\n    // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\n    function getBaseAssetDeltaThisFundingPeriod() external view override returns (SignedDecimal.signedDecimal memory) {\n        return baseAssetDeltaThisFundingPeriod;\n    }\n\n    function getMaxHoldingBaseAsset() external view override returns (Decimal.decimal memory) {\n        return maxHoldingBaseAsset;\n    }\n\n    function getOpenInterestNotionalCap() external view override returns (Decimal.decimal memory) {\n        return openInterestNotionalCap;\n    }\n\n    function getBaseAssetDelta() external view override returns (SignedDecimal.signedDecimal memory) {\n        return totalPositionSize;\n    }\n\n    function isOverSpreadLimit() external view override returns (bool) {\n        Decimal.decimal memory oraclePrice = getUnderlyingPrice();\n        require(oraclePrice.toUint() > 0, \"underlying price is 0\");\n        Decimal.decimal memory marketPrice = getSpotPrice();\n        Decimal.decimal memory oracleSpreadRatioAbs =\n            MixedDecimal.fromDecimal(marketPrice).subD(oraclePrice).divD(oraclePrice).abs();\n\n        return oracleSpreadRatioAbs.toUint() >= MAX_ORACLE_SPREAD_RATIO ? true : false;\n    }\n\n    /**\n     * @notice calculate total fee (including toll and spread) by input quoteAssetAmount\n     * @param _quoteAssetAmount quoteAssetAmount\n     * @return total tx fee\n     */\n    function calcFee(Decimal.decimal calldata _quoteAssetAmount)\n        external\n        view\n        override\n        returns (Decimal.decimal memory, Decimal.decimal memory)\n    {\n        if (_quoteAssetAmount.toUint() == 0) {\n            return (Decimal.zero(), Decimal.zero());\n        }\n        return (_quoteAssetAmount.mulD(tollRatio), _quoteAssetAmount.mulD(spreadRatio));\n    }\n\n    /*       plus/minus 1 while the amount is not dividable\n     *\n     *        getInputPrice                         getOutputPrice\n     *\n     *     ＡＤＤ      (amount - 1)              (amount + 1)   ＲＥＭＯＶＥ\n     *      ◥◤            ▲                         |             ◢◣\n     *      ◥◤  ------->  |                         ▼  <--------  ◢◣\n     *    -------      -------                   -------        -------\n     *    |  Q  |      |  B  |                   |  Q  |        |  B  |\n     *    -------      -------                   -------        -------\n     *      ◥◤  ------->  ▲                         |  <--------  ◢◣\n     *      ◥◤            |                         ▼             ◢◣\n     *   ＲＥＭＯＶＥ  (amount + 1)              (amount + 1)      ＡＤＤ\n     **/\n\n    function getInputPriceWithReserves(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) public pure override returns (Decimal.decimal memory) {\n        if (_quoteAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n\n        bool isAddToAmm = _dirOfQuote == Dir.ADD_TO_AMM;\n        SignedDecimal.signedDecimal memory invariant =\n            MixedDecimal.fromDecimal(_quoteAssetPoolAmount.mulD(_baseAssetPoolAmount));\n        SignedDecimal.signedDecimal memory baseAssetAfter;\n        Decimal.decimal memory quoteAssetAfter;\n        Decimal.decimal memory baseAssetBought;\n        if (isAddToAmm) {\n            quoteAssetAfter = _quoteAssetPoolAmount.addD(_quoteAssetAmount);\n        } else {\n            quoteAssetAfter = _quoteAssetPoolAmount.subD(_quoteAssetAmount);\n        }\n        require(quoteAssetAfter.toUint() != 0, \"quote asset after is 0\");\n\n        baseAssetAfter = invariant.divD(quoteAssetAfter);\n        baseAssetBought = baseAssetAfter.subD(_baseAssetPoolAmount).abs();\n\n        // if the amount is not dividable, return 1 wei less for trader\n        if (invariant.abs().modD(quoteAssetAfter).toUint() != 0) {\n            if (isAddToAmm) {\n                baseAssetBought = baseAssetBought.subD(Decimal.decimal(1));\n            } else {\n                baseAssetBought = baseAssetBought.addD(Decimal.decimal(1));\n            }\n        }\n\n        return baseAssetBought;\n    }\n\n    function getOutputPriceWithReserves(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) public pure override returns (Decimal.decimal memory) {\n        if (_baseAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n\n        bool isAddToAmm = _dirOfBase == Dir.ADD_TO_AMM;\n        SignedDecimal.signedDecimal memory invariant =\n            MixedDecimal.fromDecimal(_quoteAssetPoolAmount.mulD(_baseAssetPoolAmount));\n        SignedDecimal.signedDecimal memory quoteAssetAfter;\n        Decimal.decimal memory baseAssetAfter;\n        Decimal.decimal memory quoteAssetSold;\n\n        if (isAddToAmm) {\n            baseAssetAfter = _baseAssetPoolAmount.addD(_baseAssetAmount);\n        } else {\n            baseAssetAfter = _baseAssetPoolAmount.subD(_baseAssetAmount);\n        }\n        require(baseAssetAfter.toUint() != 0, \"base asset after is 0\");\n\n        quoteAssetAfter = invariant.divD(baseAssetAfter);\n        quoteAssetSold = quoteAssetAfter.subD(_quoteAssetPoolAmount).abs();\n\n        // if the amount is not dividable, return 1 wei less for trader\n        if (invariant.abs().modD(baseAssetAfter).toUint() != 0) {\n            if (isAddToAmm) {\n                quoteAssetSold = quoteAssetSold.subD(Decimal.decimal(1));\n            } else {\n                quoteAssetSold = quoteAssetSold.addD(Decimal.decimal(1));\n            }\n        }\n\n        return quoteAssetSold;\n    }\n\n    //\n    // INTERNAL FUNCTIONS\n    //\n    // update funding rate = premiumFraction / twapIndexPrice\n    function updateFundingRate(\n        SignedDecimal.signedDecimal memory _premiumFraction,\n        Decimal.decimal memory _underlyingPrice\n    ) private {\n        fundingRate = _premiumFraction.divD(_underlyingPrice);\n        emit FundingRateUpdated(fundingRate.toInt(), _underlyingPrice.toUint());\n    }\n\n    function addReserveSnapshot() internal {\n        uint256 currentBlock = _blockNumber();\n        ReserveSnapshot storage latestSnapshot = reserveSnapshots[reserveSnapshots.length - 1];\n        // update values in snapshot if in the same block\n        if (currentBlock == latestSnapshot.blockNumber) {\n            latestSnapshot.quoteAssetReserve = quoteAssetReserve;\n            latestSnapshot.baseAssetReserve = baseAssetReserve;\n        } else {\n            reserveSnapshots.push(\n                ReserveSnapshot(quoteAssetReserve, baseAssetReserve, _blockTimestamp(), currentBlock)\n            );\n        }\n        emit ReserveSnapshotted(quoteAssetReserve.toUint(), baseAssetReserve.toUint(), _blockTimestamp());\n    }\n\n    function implSwapOutput(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) internal returns (Decimal.decimal memory) {\n        if (_baseAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n        if (_dirOfBase == Dir.REMOVE_FROM_AMM) {\n            require(baseAssetReserve.mulD(tradeLimitRatio).toUint() >= _baseAssetAmount.toUint(), \"over trading limit\");\n        }\n\n        Decimal.decimal memory quoteAssetAmount = getOutputPrice(_dirOfBase, _baseAssetAmount);\n        Dir dirOfQuote = _dirOfBase == Dir.ADD_TO_AMM ? Dir.REMOVE_FROM_AMM : Dir.ADD_TO_AMM;\n        // If SHORT, exchanged quote amount should be less than _quoteAssetAmountLimit,\n        // otherwise(LONG), exchanged base amount should be more than _quoteAssetAmountLimit.\n        // In the SHORT case, more quote assets means more payment so should not be more than _quoteAssetAmountLimit\n        if (_quoteAssetAmountLimit.toUint() != 0) {\n            if (dirOfQuote == Dir.REMOVE_FROM_AMM) {\n                // SHORT\n                require(quoteAssetAmount.toUint() >= _quoteAssetAmountLimit.toUint(), \"Less than minimal quote token\");\n            } else {\n                // LONG\n                require(quoteAssetAmount.toUint() <= _quoteAssetAmountLimit.toUint(), \"More than maximal quote token\");\n            }\n        }\n\n        // as mentioned in swapOutput(), it always allows going over fluctuation limit because\n        // it is only used by close/liquidate positions\n        updateReserve(dirOfQuote, quoteAssetAmount, _baseAssetAmount, true);\n        emit SwapOutput(_dirOfBase, quoteAssetAmount.toUint(), _baseAssetAmount.toUint());\n        return quoteAssetAmount;\n    }\n\n    // the direction is in quote asset\n    function updateReserve(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _baseAssetAmount,\n        bool _canOverFluctuationLimit\n    ) internal {\n        // check if it's over fluctuationLimitRatio\n        // this check should be before reserves being updated\n        checkIsOverBlockFluctuationLimit(_dirOfQuote, _quoteAssetAmount, _baseAssetAmount, _canOverFluctuationLimit);\n\n        if (_dirOfQuote == Dir.ADD_TO_AMM) {\n            quoteAssetReserve = quoteAssetReserve.addD(_quoteAssetAmount);\n            baseAssetReserve = baseAssetReserve.subD(_baseAssetAmount);\n            // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\n            baseAssetDeltaThisFundingPeriod = baseAssetDeltaThisFundingPeriod.subD(_baseAssetAmount);\n            totalPositionSize = totalPositionSize.addD(_baseAssetAmount);\n            cumulativeNotional = cumulativeNotional.addD(_quoteAssetAmount);\n        } else {\n            quoteAssetReserve = quoteAssetReserve.subD(_quoteAssetAmount);\n            baseAssetReserve = baseAssetReserve.addD(_baseAssetAmount);\n            // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\n            baseAssetDeltaThisFundingPeriod = baseAssetDeltaThisFundingPeriod.addD(_baseAssetAmount);\n            totalPositionSize = totalPositionSize.subD(_baseAssetAmount);\n            cumulativeNotional = cumulativeNotional.subD(_quoteAssetAmount);\n        }\n\n        // addReserveSnapshot must be after checking price fluctuation\n        addReserveSnapshot();\n    }\n\n    function implGetInputAssetTwapPrice(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _assetAmount,\n        QuoteAssetDir _inOut,\n        uint256 _interval\n    ) internal view returns (Decimal.decimal memory) {\n        TwapPriceCalcParams memory params;\n        params.opt = TwapCalcOption.INPUT_ASSET;\n        params.snapshotIndex = reserveSnapshots.length.sub(1);\n        params.asset.dir = _dirOfQuote;\n        params.asset.assetAmount = _assetAmount;\n        params.asset.inOrOut = _inOut;\n        return calcTwap(params, _interval);\n    }\n\n    function implGetReserveTwapPrice(uint256 _interval) internal view returns (Decimal.decimal memory) {\n        TwapPriceCalcParams memory params;\n        params.opt = TwapCalcOption.RESERVE_ASSET;\n        params.snapshotIndex = reserveSnapshots.length.sub(1);\n        return calcTwap(params, _interval);\n    }\n\n    function calcTwap(TwapPriceCalcParams memory _params, uint256 _interval)\n        internal\n        view\n        returns (Decimal.decimal memory)\n    {\n        Decimal.decimal memory currentPrice = getPriceWithSpecificSnapshot(_params);\n        if (_interval == 0) {\n            return currentPrice;\n        }\n\n        uint256 baseTimestamp = _blockTimestamp().sub(_interval);\n        ReserveSnapshot memory currentSnapshot = reserveSnapshots[_params.snapshotIndex];\n        // return the latest snapshot price directly\n        // if only one snapshot or the timestamp of latest snapshot is earlier than asking for\n        if (reserveSnapshots.length == 1 || currentSnapshot.timestamp <= baseTimestamp) {\n            return currentPrice;\n        }\n\n        uint256 previousTimestamp = currentSnapshot.timestamp;\n        uint256 period = _blockTimestamp().sub(previousTimestamp);\n        Decimal.decimal memory weightedPrice = currentPrice.mulScalar(period);\n        while (true) {\n            // if snapshot history is too short\n            if (_params.snapshotIndex == 0) {\n                return weightedPrice.divScalar(period);\n            }\n\n            _params.snapshotIndex = _params.snapshotIndex.sub(1);\n            currentSnapshot = reserveSnapshots[_params.snapshotIndex];\n            currentPrice = getPriceWithSpecificSnapshot(_params);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentSnapshot.timestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, _interval is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice.addD(currentPrice.mulScalar(previousTimestamp.sub(baseTimestamp)));\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp.sub(currentSnapshot.timestamp);\n            weightedPrice = weightedPrice.addD(currentPrice.mulScalar(timeFraction));\n            period = period.add(timeFraction);\n            previousTimestamp = currentSnapshot.timestamp;\n        }\n        return weightedPrice.divScalar(_interval);\n    }\n\n    function getPriceWithSpecificSnapshot(TwapPriceCalcParams memory params)\n        internal\n        view\n        virtual\n        returns (Decimal.decimal memory)\n    {\n        ReserveSnapshot memory snapshot = reserveSnapshots[params.snapshotIndex];\n\n        // RESERVE_ASSET means price comes from quoteAssetReserve/baseAssetReserve\n        // INPUT_ASSET means getInput/Output price with snapshot's reserve\n        if (params.opt == TwapCalcOption.RESERVE_ASSET) {\n            return snapshot.quoteAssetReserve.divD(snapshot.baseAssetReserve);\n        } else if (params.opt == TwapCalcOption.INPUT_ASSET) {\n            if (params.asset.assetAmount.toUint() == 0) {\n                return Decimal.zero();\n            }\n            if (params.asset.inOrOut == QuoteAssetDir.QUOTE_IN) {\n                return\n                    getInputPriceWithReserves(\n                        params.asset.dir,\n                        params.asset.assetAmount,\n                        snapshot.quoteAssetReserve,\n                        snapshot.baseAssetReserve\n                    );\n            } else if (params.asset.inOrOut == QuoteAssetDir.QUOTE_OUT) {\n                return\n                    getOutputPriceWithReserves(\n                        params.asset.dir,\n                        params.asset.assetAmount,\n                        snapshot.quoteAssetReserve,\n                        snapshot.baseAssetReserve\n                    );\n            }\n        }\n        revert(\"not supported option\");\n    }\n\n    function getPriceBoundariesOfLastBlock() internal view returns (Decimal.decimal memory, Decimal.decimal memory) {\n        uint256 len = reserveSnapshots.length;\n        ReserveSnapshot memory latestSnapshot = reserveSnapshots[len.sub(1)];\n        // if the latest snapshot is the same as current block, get the previous one\n        if (latestSnapshot.blockNumber == _blockNumber() && len > 1) {\n            latestSnapshot = reserveSnapshots[len.sub(2)];\n        }\n\n        Decimal.decimal memory lastPrice = latestSnapshot.quoteAssetReserve.divD(latestSnapshot.baseAssetReserve);\n        Decimal.decimal memory upperLimit = lastPrice.mulD(Decimal.one().addD(fluctuationLimitRatio));\n        Decimal.decimal memory lowerLimit = lastPrice.mulD(Decimal.one().subD(fluctuationLimitRatio));\n        return (upperLimit, lowerLimit);\n    }\n\n    /**\n     * @notice there can only be one tx in a block can skip the fluctuation check\n     *         otherwise, some positions can never be closed or liquidated\n     * @param _canOverFluctuationLimit if true, can skip fluctuation check for once; else, can never skip\n     */\n    function checkIsOverBlockFluctuationLimit(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _baseAssetAmount,\n        bool _canOverFluctuationLimit\n    ) internal view {\n        // Skip the check if the limit is 0\n        if (fluctuationLimitRatio.toUint() == 0) {\n            return;\n        }\n\n        //\n        // assume the price of the last block is 10, fluctuation limit ratio is 5%, then\n        //\n        //          current price\n        //  --+---------+-----------+---\n        //   9.5        10         10.5\n        // lower limit           upper limit\n        //\n        // when `openPosition`, the price can only be between 9.5 - 10.5\n        // when `liquidate` and `closePosition`, the price can exceed the boundary once\n        // (either lower than 9.5 or higher than 10.5)\n        // once it exceeds the boundary, all the rest txs in this block fail\n        //\n\n        (Decimal.decimal memory upperLimit, Decimal.decimal memory lowerLimit) = getPriceBoundariesOfLastBlock();\n\n        Decimal.decimal memory price = quoteAssetReserve.divD(baseAssetReserve);\n        require(price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0, \"price is already over fluctuation limit\");\n\n        if (!_canOverFluctuationLimit) {\n            price = (_dirOfQuote == Dir.ADD_TO_AMM)\n                ? quoteAssetReserve.addD(_quoteAssetAmount).divD(baseAssetReserve.subD(_baseAssetAmount))\n                : quoteAssetReserve.subD(_quoteAssetAmount).divD(baseAssetReserve.addD(_baseAssetAmount));\n            require(price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0, \"price is over fluctuation limit\");\n        }\n    }\n\n    function checkLiquidityMultiplierLimit(\n        SignedDecimal.signedDecimal memory _positionSize,\n        Decimal.decimal memory _liquidityMultiplier\n    ) internal view {\n        // have lower bound when position size is long\n        if (_positionSize.toInt() > 0) {\n            Decimal.decimal memory liquidityMultiplierLowerBound =\n                _positionSize\n                    .addD(Decimal.decimal(MARGIN_FOR_LIQUIDITY_MIGRATION_ROUNDING))\n                    .divD(baseAssetReserve)\n                    .abs();\n            require(_liquidityMultiplier.cmp(liquidityMultiplierLowerBound) >= 0, \"illegal liquidity multiplier\");\n        }\n    }\n\n    function implShutdown() internal {\n        LiquidityChangedSnapshot memory latestLiquiditySnapshot = getLatestLiquidityChangedSnapshots();\n\n        // get last liquidity changed history to calc new quote/base reserve\n        Decimal.decimal memory previousK =\n            latestLiquiditySnapshot.baseAssetReserve.mulD(latestLiquiditySnapshot.quoteAssetReserve);\n        SignedDecimal.signedDecimal memory lastInitBaseReserveInNewCurve =\n            latestLiquiditySnapshot.totalPositionSize.addD(latestLiquiditySnapshot.baseAssetReserve);\n        SignedDecimal.signedDecimal memory lastInitQuoteReserveInNewCurve =\n            MixedDecimal.fromDecimal(previousK).divD(lastInitBaseReserveInNewCurve);\n\n        // settlementPrice = SUM(Open Position Notional Value) / SUM(Position Size)\n        // `Open Position Notional Value` = init quote reserve - current quote reserve\n        // `Position Size` = init base reserve - current base reserve\n        SignedDecimal.signedDecimal memory positionNotionalValue =\n            lastInitQuoteReserveInNewCurve.subD(quoteAssetReserve);\n\n        // if total position size less than IGNORABLE_DIGIT_FOR_SHUTDOWN, treat it as 0 positions due to rounding error\n        if (totalPositionSize.toUint() > IGNORABLE_DIGIT_FOR_SHUTDOWN) {\n            settlementPrice = positionNotionalValue.abs().divD(totalPositionSize.abs());\n        }\n\n        open = false;\n        emit Shutdown(settlementPrice.toUint());\n    }\n}\n"
    },
    "contracts/utils/BlockContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\n// wrap block.xxx functions for testing\n// only support timestamp and number so far\nabstract contract BlockContext {\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _blockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "contracts/interface/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IPriceFeed {\n    // get latest price\n    function getPrice(bytes32 _priceFeedKey) external view returns (uint256);\n\n    // get previous price with _back rounds\n    // function getPreviousPrice(bytes32 _priceFeedKey, uint256 _numOfRoundBack) external view returns (uint256);\n\n    // get twap price depending on _period\n    // function getTwapPrice(bytes32 _priceFeedKey, uint256 _interval) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/utils/Decimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.6.0 <=0.9.0;\n\nimport {SafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport {DecimalMath} from \"./DecimalMath.sol\";\n\nlibrary Decimal {\n    using DecimalMath for uint256;\n    using SafeMath for uint256;\n\n    struct decimal {\n        uint256 d;\n    }\n\n    function zero() internal pure returns (decimal memory) {\n        return decimal(0);\n    }\n\n    function one() internal pure returns (decimal memory) {\n        return decimal(DecimalMath.unit(18));\n    }\n\n    function toUint(decimal memory x) internal pure returns (uint256) {\n        return x.d;\n    }\n\n    function modD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\n        return decimal(x.d.mul(DecimalMath.unit(18)) % y.d);\n    }\n\n    function cmp(decimal memory x, decimal memory y) internal pure returns (int8) {\n        if (x.d > y.d) {\n            return 1;\n        } else if (x.d < y.d) {\n            return -1;\n        }\n        return 0;\n    }\n\n    /// @dev add two decimals\n    function addD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.add(y.d);\n        return t;\n    }\n\n    /// @dev subtract two decimals\n    function subD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.sub(y.d);\n        return t;\n    }\n\n    /// @dev multiple two decimals\n    function mulD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.muld(y.d);\n        return t;\n    }\n\n    /// @dev multiple a decimal by a uint256\n    function mulScalar(decimal memory x, uint256 y) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.mul(y);\n        return t;\n    }\n\n    /// @dev divide two decimals\n    function divD(decimal memory x, decimal memory y) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.divd(y.d);\n        return t;\n    }\n\n    /// @dev divide a decimal by a uint256\n    function divScalar(decimal memory x, uint256 y) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.div(y);\n        return t;\n    }\n}\n"
    },
    "contracts/utils/SignedDecimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport {SignedSafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\";\nimport {SignedDecimalMath} from \"./SignedDecimalMath.sol\";\nimport {Decimal} from \"./Decimal.sol\";\n\nlibrary SignedDecimal {\n    using SignedDecimalMath for int256;\n    using SignedSafeMath for int256;\n\n    struct signedDecimal {\n        int256 d;\n    }\n\n    function zero() internal pure returns (signedDecimal memory) {\n        return signedDecimal(0);\n    }\n\n    function toInt(signedDecimal memory x) internal pure returns (int256) {\n        return x.d;\n    }\n\n    function isNegative(signedDecimal memory x) internal pure returns (bool) {\n        if (x.d < 0) {\n            return true;\n        }\n        return false;\n    }\n\n    function abs(signedDecimal memory x) internal pure returns (Decimal.decimal memory) {\n        Decimal.decimal memory t;\n        if (x.d < 0) {\n            t.d = uint256(0 - x.d);\n        } else {\n            t.d = uint256(x.d);\n        }\n        return t;\n    }\n\n    /// @dev add two decimals\n    function addD(signedDecimal memory x, signedDecimal memory y)\n        internal\n        pure\n        returns (signedDecimal memory)\n    {\n        signedDecimal memory t;\n        t.d = x.d.add(y.d);\n        return t;\n    }\n\n    /// @dev subtract two decimals\n    function subD(signedDecimal memory x, signedDecimal memory y)\n        internal\n        pure\n        returns (signedDecimal memory)\n    {\n        signedDecimal memory t;\n        t.d = x.d.sub(y.d);\n        return t;\n    }\n\n    /// @dev multiple two decimals\n    function mulD(signedDecimal memory x, signedDecimal memory y)\n        internal\n        pure\n        returns (signedDecimal memory)\n    {\n        signedDecimal memory t;\n        t.d = x.d.muld(y.d);\n        return t;\n    }\n\n    /// @dev multiple a signedDecimal by a int256\n    function mulScalar(signedDecimal memory x, int256 y)\n        internal\n        pure\n        returns (signedDecimal memory)\n    {\n        signedDecimal memory t;\n        t.d = x.d.mul(y);\n        return t;\n    }\n\n    /// @dev divide two decimals\n    function divD(signedDecimal memory x, signedDecimal memory y)\n        internal\n        pure\n        returns (signedDecimal memory)\n    {\n        signedDecimal memory t;\n        t.d = x.d.divd(y.d);\n        return t;\n    }\n\n    /// @dev divide a signedDecimal by a int256\n    function divScalar(signedDecimal memory x, int256 y)\n        internal\n        pure\n        returns (signedDecimal memory)\n    {\n        signedDecimal memory t;\n        t.d = x.d.div(y);\n        return t;\n    }\n}\n"
    },
    "contracts/utils/MixedDecimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport {Decimal} from \"./Decimal.sol\";\nimport {SignedDecimal} from \"./SignedDecimal.sol\";\nimport {SignedSafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\";\n\n/// @dev To handle a signedDecimal add/sub/mul/div a decimal and provide convert decimal to signedDecimal helper\nlibrary MixedDecimal {\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using SignedSafeMath for int256;\n\n    uint256 private constant _INT256_MAX = 2**255 - 1;\n    string private constant ERROR_NON_CONVERTIBLE =\n        \"MixedDecimal: uint value is bigger than _INT256_MAX\";\n\n    modifier convertible(Decimal.decimal memory x) {\n        require(_INT256_MAX >= x.d, ERROR_NON_CONVERTIBLE);\n        _;\n    }\n\n    function fromDecimal(Decimal.decimal memory x)\n        internal\n        pure\n        convertible(x)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        return SignedDecimal.signedDecimal(int256(x.d));\n    }\n\n    function toUint(SignedDecimal.signedDecimal memory x) internal pure returns (uint256) {\n        return x.abs().d;\n    }\n\n    /// @dev add SignedDecimal.signedDecimal and Decimal.decimal, using SignedSafeMath directly\n    function addD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t.d = x.d.add(int256(y.d));\n        return t;\n    }\n\n    /// @dev subtract SignedDecimal.signedDecimal by Decimal.decimal, using SignedSafeMath directly\n    function subD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t.d = x.d.sub(int256(y.d));\n        return t;\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by Decimal.decimal\n    function mulD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t = x.mulD(fromDecimal(y));\n        return t;\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by a uint256\n    function mulScalar(SignedDecimal.signedDecimal memory x, uint256 y)\n        internal\n        pure\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        require(_INT256_MAX >= y, ERROR_NON_CONVERTIBLE);\n        SignedDecimal.signedDecimal memory t;\n        t = x.mulScalar(int256(y));\n        return t;\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a Decimal.decimal\n    function divD(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t = x.divD(fromDecimal(y));\n        return t;\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a uint256\n    function divScalar(SignedDecimal.signedDecimal memory x, uint256 y)\n        internal\n        pure\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        require(_INT256_MAX >= y, ERROR_NON_CONVERTIBLE);\n        SignedDecimal.signedDecimal memory t;\n        t = x.divScalar(int256(y));\n        return t;\n    }\n}\n"
    },
    "contracts/utils/IfnxFiOwnableUpgrade.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport {ContextUpgradeSafe} from \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\";\n\n// copy from openzeppelin Ownable, only modify how the owner transfer\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract IfnxFiOwnableUpgrade is ContextUpgradeSafe {\n    address private _owner;\n    address private _candidate;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function candidate() public view returns (address) {\n        return _candidate;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"IfnxFiOwnableUpgrade: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Set ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function setOwner(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"IfnxFiOwnableUpgrade: zero address\");\n        require(newOwner != _owner, \"IfnxFiOwnableUpgrade: same as original\");\n        require(newOwner != _candidate, \"IfnxFiOwnableUpgrade: same as candidate\");\n        _candidate = newOwner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`_candidate`).\n     * Can only be called by the new owner.\n     */\n    function updateOwner() public {\n        require(_candidate != address(0), \"IfnxFiOwnableUpgrade: candidate is zero address\");\n        require(_candidate == _msgSender(), \"IfnxFiOwnableUpgrade: not the new owner\");\n\n        emit OwnershipTransferred(_owner, _candidate);\n        _owner = _candidate;\n        _candidate = address(0);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interface/IAmm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {SignedDecimal} from \"../utils/SignedDecimal.sol\";\n\ninterface IAmm {\n    /**\n     * @notice asset direction, used in getInputPrice, getOutputPrice, swapInput and swapOutput\n     * @param ADD_TO_AMM add asset to Amm\n     * @param REMOVE_FROM_AMM remove asset from Amm\n     */\n    enum Dir {\n        ADD_TO_AMM,\n        REMOVE_FROM_AMM\n    }\n\n    struct LiquidityChangedSnapshot {\n        SignedDecimal.signedDecimal cumulativeNotional;\n        // the base/quote reserve of amm right before liquidity changed\n        Decimal.decimal quoteAssetReserve;\n        Decimal.decimal baseAssetReserve;\n        // total position size owned by amm after last snapshot taken\n        // `totalPositionSize` = currentBaseAssetReserve - lastLiquidityChangedHistoryItem.baseAssetReserve + prevTotalPositionSize\n        SignedDecimal.signedDecimal totalPositionSize;\n    }\n\n    function swapInput(\n        Dir _dir,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _baseAssetAmountLimit,\n        bool _canOverFluctuationLimit\n    ) external returns (Decimal.decimal memory);\n\n    function swapOutput(\n        Dir _dir,\n        Decimal.decimal calldata _baseAssetAmount,\n        Decimal.decimal calldata _quoteAssetAmountLimit\n    ) external returns (Decimal.decimal memory);\n\n    function shutdown() external;\n\n    function settleFunding() external returns (SignedDecimal.signedDecimal memory);\n\n    function calcFee(Decimal.decimal calldata _quoteAssetAmount)\n        external\n        view\n        returns (Decimal.decimal memory, Decimal.decimal memory);\n\n    //\n    // VIEW\n    //\n\n    function isOverFluctuationLimit(Dir _dirOfBase, Decimal.decimal memory _baseAssetAmount)\n        external\n        view\n        returns (bool);\n\n    function calcBaseAssetAfterLiquidityMigration(\n        SignedDecimal.signedDecimal memory _baseAssetAmount,\n        Decimal.decimal memory _fromQuoteReserve,\n        Decimal.decimal memory _fromBaseReserve\n    ) external view returns (SignedDecimal.signedDecimal memory);\n\n    function getInputTwap(Dir _dir, Decimal.decimal calldata _quoteAssetAmount)\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getOutputTwap(Dir _dir, Decimal.decimal calldata _baseAssetAmount)\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getInputPrice(Dir _dir, Decimal.decimal calldata _quoteAssetAmount)\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getOutputPrice(Dir _dir, Decimal.decimal calldata _baseAssetAmount)\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getInputPriceWithReserves(\n        Dir _dir,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) external pure returns (Decimal.decimal memory);\n\n    function getOutputPriceWithReserves(\n        Dir _dir,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) external pure returns (Decimal.decimal memory);\n\n    function getSpotPrice() external view returns (Decimal.decimal memory);\n\n    function getLiquidityHistoryLength() external view returns (uint256);\n\n    // overridden by state variable\n    function quoteAsset() external view returns (IERC20);\n\n    function open() external view returns (bool);\n\n    // can not be overridden by state variable due to type `Deciaml.decimal`\n    function getSettlementPrice() external view returns (Decimal.decimal memory);\n\n    function getBaseAssetDeltaThisFundingPeriod()\n        external\n        view\n        returns (SignedDecimal.signedDecimal memory);\n\n    function getCumulativeNotional() external view returns (SignedDecimal.signedDecimal memory);\n\n    function getMaxHoldingBaseAsset() external view returns (Decimal.decimal memory);\n\n    function getOpenInterestNotionalCap() external view returns (Decimal.decimal memory);\n\n    function getLiquidityChangedSnapshots(uint256 i)\n        external\n        view\n        returns (LiquidityChangedSnapshot memory);\n\n    function getBaseAssetDelta() external view returns (SignedDecimal.signedDecimal memory);\n\n    function getUnderlyingPrice() external view returns (Decimal.decimal memory);\n\n    function isOverSpreadLimit() external view returns (bool);\n}\n"
    },
    "contracts/utils/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/// @dev Implements simple fixed point math add, sub, mul and div operations.\n/// @author Alberto Cuesta Cañada\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    /// @dev Returns 1 in the fixed point representation, with `decimals` decimals.\n    function unit(uint8 decimals) internal pure returns (uint256) {\n        return 10**uint256(decimals);\n    }\n\n    /// @dev Adds x and y, assuming they are both fixed point with 18 decimals.\n    function addd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x.add(y);\n    }\n\n    /// @dev Subtracts y from x, assuming they are both fixed point with 18 decimals.\n    function subd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x.sub(y);\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with 18 digits.\n    function muld(uint256 x, uint256 y) internal pure returns (uint256) {\n        return muld(x, y, 18);\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with `decimals` digits.\n    function muld(\n        uint256 x,\n        uint256 y,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        return x.mul(y).div(unit(decimals));\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with 18 digits.\n    function divd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return divd(x, y, 18);\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with `decimals` digits.\n    function divd(\n        uint256 x,\n        uint256 y,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        return x.mul(unit(decimals)).div(y);\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/utils/SignedDecimalMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport {SignedSafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\";\n\n/// @dev Implements simple signed fixed point math add, sub, mul and div operations.\nlibrary SignedDecimalMath {\n    using SignedSafeMath for int256;\n\n    /// @dev Returns 1 in the fixed point representation, with `decimals` decimals.\n    function unit(uint8 decimals) internal pure returns (int256) {\n        return int256(10**uint256(decimals));\n    }\n\n    /// @dev Adds x and y, assuming they are both fixed point with 18 decimals.\n    function addd(int256 x, int256 y) internal pure returns (int256) {\n        return x.add(y);\n    }\n\n    /// @dev Subtracts y from x, assuming they are both fixed point with 18 decimals.\n    function subd(int256 x, int256 y) internal pure returns (int256) {\n        return x.sub(y);\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with 18 digits.\n    function muld(int256 x, int256 y) internal pure returns (int256) {\n        return muld(x, y, 18);\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with `decimals` digits.\n    function muld(\n        int256 x,\n        int256 y,\n        uint8 decimals\n    ) internal pure returns (int256) {\n        return x.mul(y).div(unit(decimals));\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with 18 digits.\n    function divd(int256 x, int256 y) internal pure returns (int256) {\n        return divd(x, y, 18);\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with `decimals` digits.\n    function divd(\n        int256 x,\n        int256 y,\n        uint8 decimals\n    ) internal pure returns (int256) {\n        return x.mul(unit(decimals)).div(y);\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/mock/TraderWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {ClearingHouseFake} from \"./ClearingHouseFake.sol\";\nimport {Amm} from \"../Amm.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ncontract TraderWallet {\n    ClearingHouseFake public clearingHouse;\n\n    enum ActionType {\n        OPEN,\n        CLOSE,\n        LIQUIDATE\n    }\n\n    constructor(ClearingHouseFake _clearingHouse, IERC20 _token) public {\n        clearingHouse = _clearingHouse;\n        _token.approve(address(clearingHouse), uint256(-1));\n    }\n\n    function openPosition(\n        Amm _amm,\n        ClearingHouseFake.Side _side,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _leverage,\n        Decimal.decimal calldata _minBaseAssetAmount\n    ) external {\n        clearingHouse.openPosition(_amm, _side, _quoteAssetAmount, _leverage, _minBaseAssetAmount);\n    }\n\n    function liquidate(\n        Amm _amm,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmount\n    ) external {\n        clearingHouse.liquidateWithSlippage(_amm, _trader, _quoteAssetAmount);\n    }\n\n    function closePosition(Amm _amm) external {\n        clearingHouse.closePosition(_amm, Decimal.zero());\n    }\n\n    function multiActions(\n        ActionType _action1,\n        bool _setRestriction,\n        ActionType _action2,\n        Amm _amm,\n        ClearingHouseFake.Side _side,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _leverage,\n        Decimal.decimal calldata _baseAssetAmountLimit,\n        address _trader\n    ) external {\n        executeAction(\n            _action1,\n            _amm,\n            _side,\n            _quoteAssetAmount,\n            _leverage,\n            _baseAssetAmountLimit,\n            _trader\n        );\n        if (_setRestriction) {\n            clearingHouse.mockSetRestrictionMode(_amm);\n        }\n        executeAction(\n            _action2,\n            _amm,\n            _side,\n            _quoteAssetAmount,\n            _leverage,\n            _baseAssetAmountLimit,\n            _trader\n        );\n    }\n\n    function twoLiquidations(\n        Amm _amm,\n        address _trader1,\n        address _trader2\n    ) external {\n        clearingHouse.liquidate(_amm, _trader1);\n        clearingHouse.liquidate(_amm, _trader2);\n    }\n\n    function threeLiquidations(\n        Amm _amm,\n        address _trader1,\n        address _trader2,\n        address _trader3\n    ) external {\n        clearingHouse.liquidate(_amm, _trader1);\n        clearingHouse.liquidate(_amm, _trader2);\n        clearingHouse.liquidate(_amm, _trader3);\n    }\n\n    function executeAction(\n        ActionType _action,\n        Amm _amm,\n        ClearingHouseFake.Side _side,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit,\n        address _trader\n    ) internal {\n        if (_action == ActionType.OPEN) {\n            clearingHouse.openPosition(\n                _amm,\n                _side,\n                _quoteAssetAmount,\n                _leverage,\n                _baseAssetAmountLimit\n            );\n        } else if (_action == ActionType.CLOSE) {\n            clearingHouse.closePosition(_amm, Decimal.zero());\n        } else if (_action == ActionType.LIQUIDATE) {\n            clearingHouse.liquidate(_amm, _trader);\n        }\n    }\n}\n"
    },
    "contracts/mock/ClearingHouseFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../ClearingHouse.sol\";\nimport \"../interface/IAmm.sol\";\n\n// temporary commented unused functions to bypass contract too large error\ncontract ClearingHouseFake is ClearingHouse {\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    function initialize_Fake(\n        uint256 _initMarginRatio,\n        uint256 _maintenanceMarginRatio,\n        uint256 _liquidationFeeRatio,\n        IInsuranceFund _insuranceFund\n    ) external initializer {\n        require(address(_insuranceFund) != address(0), \"Invalid IInsuranceFund\");\n\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n\n        versionRecipient = \"1.0.0\"; // we are not using it atm\n        initMarginRatio = Decimal.decimal(_initMarginRatio);\n        maintenanceMarginRatio = Decimal.decimal(_maintenanceMarginRatio);\n        liquidationFeeRatio = Decimal.decimal(_liquidationFeeRatio);\n        insuranceFund = _insuranceFund;\n    }\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    // function mock_getCurrentTimestamp() public view returns (uint256) {\n    //     return _blockTimestamp();\n    // }\n\n    function mock_getCurrentBlockNumber() public view returns (uint256) {\n        return _blockNumber();\n    }\n\n    // // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n\n    function mockSetRestrictionMode(IAmm _amm) external {\n        enterRestrictionMode(_amm);\n    }\n\n    function isInRestrictMode(address _amm, uint256 _block) external view returns (bool) {\n        return ammMap[_amm].lastRestrictionBlock == _block;\n    }\n\n    function getPrepaidBadDebt(address _token) public view returns (Decimal.decimal memory) {\n        return prepaidBadDebt[_token];\n    }\n}\n"
    },
    "contracts/ClearingHouse.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { BlockContext } from \"./utils/BlockContext.sol\";\nimport { BaseRelayRecipient } from \"@opengsn/gsn/contracts/BaseRelayRecipient.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport { Decimal } from \"./utils/Decimal.sol\";\nimport { SignedDecimal } from \"./utils/SignedDecimal.sol\";\nimport { MixedDecimal } from \"./utils/MixedDecimal.sol\";\nimport { DecimalERC20 } from \"./utils/DecimalERC20.sol\";\nimport { ContextUpgradeSafe } from \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\";\n// prettier-ignore\n// solhint-disable-next-line\nimport { ReentrancyGuardUpgradeSafe } from \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport { OwnerPausableUpgradeSafe } from \"./OwnerPausable.sol\";\nimport { IAmm } from \"./interface/IAmm.sol\";\nimport { IInsuranceFund } from \"./interface/IInsuranceFund.sol\";\nimport { IMultiTokenRewardRecipient } from \"./interface/IMultiTokenRewardRecipient.sol\";\n\n// note BaseRelayRecipient must come after OwnerPausableUpgradeSafe so its _msgSender() takes precedence\n// (yes, the ordering is reversed comparing to Python)\ncontract ClearingHouse is\n    DecimalERC20,\n    OwnerPausableUpgradeSafe,\n    ReentrancyGuardUpgradeSafe,\n    BlockContext,\n    BaseRelayRecipient\n{\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    //\n    // EVENTS\n    //\n    // event InitMarginRatioChanged(uint256 initMarginRatio);\n    // event InsuranceFundChanged(address insuranceFund);\n    // event MarginRatioChanged(uint256 marginRatio);\n    // event LiquidationFeeRatioChanged(uint256 liquidationFeeRatio);\n    event BackstopLiquidityProviderChanged(address indexed account, bool indexed isProvider);\n    event MarginChanged(address indexed sender, address indexed amm, int256 amount, int256 fundingPayment);\n    event PositionAdjusted(\n        address indexed amm,\n        address indexed trader,\n        int256 newPositionSize,\n        uint256 oldLiquidityIndex,\n        uint256 newLiquidityIndex\n    );\n    event PositionSettled(address indexed amm, address indexed trader, uint256 valueTransferred);\n    event RestrictionModeEntered(address amm, uint256 blockNumber);\n\n    /// @notice This event is emitted when position change\n    /// @param trader the address which execute this transaction\n    /// @param amm IAmm address\n    /// @param margin margin\n    /// @param positionNotional margin * leverage\n    /// @param exchangedPositionSize position size, e.g. ETHUSDC or LINKUSDC\n    /// @param fee transaction fee\n    /// @param positionSizeAfter position size after this transaction, might be increased or decreased\n    /// @param realizedPnl realized pnl after this position changed\n    /// @param unrealizedPnlAfter unrealized pnl after this position changed\n    /// @param badDebt position change amount cleared by insurance funds\n    /// @param liquidationPenalty amount of remaining margin lost due to liquidation\n    /// @param spotPrice quote asset reserve / base asset reserve\n    /// @param fundingPayment funding payment (+: trader paid, -: trader received)\n    event PositionChanged(\n        address indexed trader,\n        address indexed amm,\n        uint256 margin,\n        uint256 positionNotional,\n        int256 exchangedPositionSize,\n        uint256 fee,\n        int256 positionSizeAfter,\n        int256 realizedPnl,\n        int256 unrealizedPnlAfter,\n        uint256 badDebt,\n        uint256 liquidationPenalty,\n        uint256 spotPrice,\n        int256 fundingPayment\n    );\n\n    /// @notice This event is emitted when position liquidated\n    /// @param trader the account address being liquidated\n    /// @param amm IAmm address\n    /// @param positionNotional liquidated position value minus liquidationFee\n    /// @param positionSize liquidated position size\n    /// @param liquidationFee liquidation fee to the liquidator\n    /// @param liquidator the address which execute this transaction\n    /// @param badDebt liquidation fee amount cleared by insurance funds\n    event PositionLiquidated(\n        address indexed trader,\n        address indexed amm,\n        uint256 positionNotional,\n        uint256 positionSize,\n        uint256 liquidationFee,\n        address liquidator,\n        uint256 badDebt\n    );\n\n    event ReferredPositionChanged(bytes32 indexed referralCode);\n\n    //\n    // Struct and Enum\n    //\n\n    enum Side { BUY, SELL }\n    enum PnlCalcOption { SPOT_PRICE, TWAP, ORACLE }\n\n    /// @param MAX_PNL most beneficial way for traders to calculate position notional\n    /// @param MIN_PNL least beneficial way for traders to calculate position notional\n    enum PnlPreferenceOption { MAX_PNL, MIN_PNL }\n\n    /// @notice This struct records personal position information\n    /// @param size denominated in amm.baseAsset\n    /// @param margin isolated margin\n    /// @param openNotional the quoteAsset value of position when opening position. the cost of the position\n    /// @param lastUpdatedCumulativePremiumFraction for calculating funding payment, record at the moment every time when trader open/reduce/close position\n    /// @param liquidityHistoryIndex\n    /// @param blockNumber the block number of the last position\n    struct Position {\n        SignedDecimal.signedDecimal size;\n        Decimal.decimal margin;\n        Decimal.decimal openNotional;\n        SignedDecimal.signedDecimal lastUpdatedCumulativePremiumFraction;\n        uint256 liquidityHistoryIndex;\n        uint256 blockNumber;\n    }\n\n    /// @notice This struct is used for avoiding stack too deep error when passing too many var between functions\n    struct PositionResp {\n        Position position;\n        // the quote asset amount trader will send if open position, will receive if close\n        Decimal.decimal exchangedQuoteAssetAmount;\n        // if realizedPnl + realizedFundingPayment + margin is negative, it's the abs value of it\n        Decimal.decimal badDebt;\n        // the base asset amount trader will receive if open position, will send if close\n        SignedDecimal.signedDecimal exchangedPositionSize;\n        // funding payment incurred during this position response\n        SignedDecimal.signedDecimal fundingPayment;\n        // realizedPnl = unrealizedPnl * closedRatio\n        SignedDecimal.signedDecimal realizedPnl;\n        // positive = trader transfer margin to vault, negative = trader receive margin from vault\n        // it's 0 when internalReducePosition, its addedMargin when internalIncreasePosition\n        // it's min(0, oldPosition + realizedFundingPayment + realizedPnl) when internalClosePosition\n        SignedDecimal.signedDecimal marginToVault;\n        // unrealized pnl after open position\n        SignedDecimal.signedDecimal unrealizedPnlAfter;\n    }\n\n    struct AmmMap {\n        // issue #1471\n        // last block when it turn restriction mode on.\n        // In restriction mode, no one can do multi open/close/liquidate position in the same block.\n        // If any underwater position being closed (having a bad debt and make insuranceFund loss),\n        // or any liquidation happened,\n        // restriction mode is ON in that block and OFF(default) in the next block.\n        // This design is to prevent the attacker being benefited from the multiple action in one block\n        // in extreme cases\n        uint256 lastRestrictionBlock;\n        SignedDecimal.signedDecimal[] cumulativePremiumFractions;\n        mapping(address => Position) positionMap;\n    }\n\n    //**********************************************************//\n    //    Can not change the order of below state variables     //\n    //**********************************************************//\n    string public override versionRecipient;\n\n    // only admin\n    Decimal.decimal public initMarginRatio;\n\n    // only admin\n    Decimal.decimal public maintenanceMarginRatio;\n\n    // only admin\n    Decimal.decimal public liquidationFeeRatio;\n\n    // key by amm address. will be deprecated or replaced after guarded period.\n    // it's not an accurate open interest, just a rough way to control the unexpected loss at the beginning\n    mapping(address => Decimal.decimal) public openInterestNotionalMap;\n\n    // key by amm address\n    mapping(address => AmmMap) internal ammMap;\n\n    // prepaid bad debt balance, key by ERC20 token address\n    mapping(address => Decimal.decimal) internal prepaidBadDebt;\n\n    // contract dependencies\n    IInsuranceFund public insuranceFund;\n    IMultiTokenRewardRecipient public feePool;\n\n    // designed for arbitragers who can hold unlimited positions. will be removed after guarded period\n    address internal whitelist;\n\n    uint256[50] private __gap;\n    //**********************************************************//\n    //    Can not change the order of above state variables     //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n    Decimal.decimal public partialLiquidationRatio;\n\n    mapping(address => bool) public backstopLiquidityProviderMap;\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    //\n\n    // FUNCTIONS\n    //\n    // openzeppelin doesn't support struct input\n    // https://github.com/OpenZeppelin/openzeppelin-sdk/issues/1523\n    function initialize(\n        uint256 _initMarginRatio,\n        uint256 _maintenanceMarginRatio,\n        uint256 _liquidationFeeRatio,\n        IInsuranceFund _insuranceFund\n    ) public initializer {\n        require(address(_insuranceFund) != address(0), \"Invalid IInsuranceFund\");\n\n        // __OwnerPausable_init();\n        __Ownable_init();\n        __Pausable_init();\n\n        // comment these out for reducing bytecode size\n        // __ReentrancyGuard_init();\n\n        initMarginRatio = Decimal.decimal(_initMarginRatio);\n        maintenanceMarginRatio = Decimal.decimal(_maintenanceMarginRatio);\n        liquidationFeeRatio = Decimal.decimal(_liquidationFeeRatio);\n        insuranceFund = _insuranceFund;\n    }\n\n    //\n    // External\n    //\n\n    /**\n     * @notice set the fee pool address\n     * @dev only owner can call\n     */\n    function setFeePool(address _feePool) external onlyOwner {\n        feePool = IMultiTokenRewardRecipient(_feePool);\n    }\n\n    /**\n     * @notice add an address in the whitelist. People in the whitelist can hold unlimited positions.\n     * @dev only owner can call\n     * @param _whitelist an address\n     */\n    function setWhitelist(address _whitelist) external onlyOwner {\n        whitelist = _whitelist;\n    }\n\n    /**\n     * @notice set backstop liquidity provider\n     * @dev only owner can call\n     * @param account provider address\n     * @param isProvider wether the account is a backstop liquidity provider\n     */\n    function setBackstopLiquidityProvider(address account, bool isProvider) external onlyOwner {\n        backstopLiquidityProviderMap[account] = isProvider;\n        emit BackstopLiquidityProviderChanged(account, isProvider);\n    }\n\n    /**\n     * @notice set the margin ratio after deleveraging\n     * @dev only owner can call\n     */\n    function setPartialLiquidationRatio(Decimal.decimal memory _ratio) external onlyOwner {\n        require(_ratio.cmp(Decimal.one()) <= 0, \"invalid partial liquidation ratio\");\n        partialLiquidationRatio = _ratio;\n    }\n\n    /**\n     * @notice add margin to increase margin ratio\n     * @param _amm IAmm address\n     * @param _addedMargin added margin in 18 digits\n     */\n    function addMargin(IAmm _amm, Decimal.decimal calldata _addedMargin) external whenNotPaused() nonReentrant() {\n        // check condition\n        requireAmm(_amm, true);\n        IERC20 quoteToken = _amm.quoteAsset();\n        requireValidTokenAmount(quoteToken, _addedMargin);\n\n        address trader = _msgSender();\n        Position memory position = getPosition(_amm, trader);\n        // update margin\n        position.margin = position.margin.addD(_addedMargin);\n\n        setPosition(_amm, trader, position);\n        // transfer token from trader\n        _transferFrom(quoteToken, trader, address(this), _addedMargin);\n        emit MarginChanged(trader, address(_amm), int256(_addedMargin.toUint()), 0);\n    }\n\n    /**\n     * @notice remove margin to decrease margin ratio\n     * @param _amm IAmm address\n     * @param _removedMargin removed margin in 18 digits\n     */\n    function removeMargin(IAmm _amm, Decimal.decimal calldata _removedMargin) external whenNotPaused() nonReentrant() {\n        // check condition\n        requireAmm(_amm, true);\n        IERC20 quoteToken = _amm.quoteAsset();\n        requireValidTokenAmount(quoteToken, _removedMargin);\n\n        address trader = _msgSender();\n        // realize funding payment if there's no bad debt\n        Position memory position = getPosition(_amm, trader);\n\n        // update margin and cumulativePremiumFraction\n        SignedDecimal.signedDecimal memory marginDelta = MixedDecimal.fromDecimal(_removedMargin).mulScalar(-1);\n        (\n            Decimal.decimal memory remainMargin,\n            Decimal.decimal memory badDebt,\n            SignedDecimal.signedDecimal memory fundingPayment,\n            SignedDecimal.signedDecimal memory latestCumulativePremiumFraction\n        ) = calcRemainMarginWithFundingPayment(_amm, position, marginDelta);\n        require(badDebt.toUint() == 0, \"margin is not enough\");\n        position.margin = remainMargin;\n        position.lastUpdatedCumulativePremiumFraction = latestCumulativePremiumFraction;\n\n        // check enough margin (same as the way Curie calculates the free collateral)\n        // Use a more conservative way to restrict traders to remove their margin\n        // We don't allow unrealized PnL to support their margin removal\n        require(\n            calcFreeCollateral(_amm, trader, remainMargin.subD(badDebt)).toInt() >= 0,\n            \"free collateral is not enough\"\n        );\n\n        setPosition(_amm, trader, position);\n\n        // transfer token back to trader\n        withdraw(quoteToken, trader, _removedMargin);\n        emit MarginChanged(trader, address(_amm), marginDelta.toInt(), fundingPayment.toInt());\n    }\n\n    /**\n     * @notice settle all the positions when amm is shutdown. The settlement price is according to IAmm.settlementPrice\n     * @param _amm IAmm address\n     */\n    function settlePosition(IAmm _amm) external nonReentrant() {\n        // check condition\n        requireAmm(_amm, false);\n        address trader = _msgSender();\n        Position memory pos = getPosition(_amm, trader);\n        requirePositionSize(pos.size);\n        // update position\n        clearPosition(_amm, trader);\n        // calculate settledValue\n        // If Settlement Price = 0, everyone takes back her collateral.\n        // else Returned Fund = Position Size * (Settlement Price - Open Price) + Collateral\n        Decimal.decimal memory settlementPrice = _amm.getSettlementPrice();\n        Decimal.decimal memory settledValue;\n        if (settlementPrice.toUint() == 0) {\n            settledValue = pos.margin;\n        } else {\n            // returnedFund = positionSize * (settlementPrice - openPrice) + positionMargin\n            // openPrice = positionOpenNotional / positionSize.abs()\n            SignedDecimal.signedDecimal memory returnedFund =\n                pos\n                    .size\n                    .mulD(MixedDecimal.fromDecimal(settlementPrice).subD(pos.openNotional.divD(pos.size.abs())))\n                    .addD(pos.margin);\n            // if `returnedFund` is negative, trader can't get anything back\n            if (returnedFund.toInt() > 0) {\n                settledValue = returnedFund.abs();\n            }\n        }\n        // transfer token based on settledValue. no insurance fund support\n        if (settledValue.toUint() > 0) {\n            _transfer(_amm.quoteAsset(), trader, settledValue);\n        }\n        // emit event\n        emit PositionSettled(address(_amm), trader, settledValue.toUint());\n    }\n\n    // if increase position\n    //   marginToVault = addMargin\n    //   marginDiff = realizedFundingPayment + realizedPnl(0)\n    //   pos.margin += marginToVault + marginDiff\n    //   vault.margin += marginToVault + marginDiff\n    //   required(enoughMarginRatio)\n    // else if reduce position()\n    //   marginToVault = 0\n    //   marginDiff = realizedFundingPayment + realizedPnl\n    //   pos.margin += marginToVault + marginDiff\n    //   if pos.margin < 0, badDebt = abs(pos.margin), set pos.margin = 0\n    //   vault.margin += marginToVault + marginDiff\n    //   required(enoughMarginRatio)\n    // else if close\n    //   marginDiff = realizedFundingPayment + realizedPnl\n    //   pos.margin += marginDiff\n    //   if pos.margin < 0, badDebt = abs(pos.margin)\n    //   marginToVault = -pos.margin\n    //   set pos.margin = 0\n    //   vault.margin += marginToVault + marginDiff\n    // else if close and open a larger position in reverse side\n    //   close()\n    //   positionNotional -= exchangedQuoteAssetAmount\n    //   newMargin = positionNotional / leverage\n    //   internalIncreasePosition(newMargin, leverage)\n    // else if liquidate\n    //   close()\n    //   pay liquidation fee to liquidator\n    //   move the remain margin to insuranceFund\n\n    // /**\n    //  * @notice open a position with referral code\n    //  * @param _amm amm address\n    //  * @param _side enum Side; BUY for long and SELL for short\n    //  * @param _quoteAssetAmount quote asset amount in 18 digits. Can Not be 0\n    //  * @param _leverage leverage  in 18 digits. Can Not be 0\n    //  * @param _baseAssetAmountLimit minimum base asset amount expected to get to prevent from slippage.\n    //  * @param _referralCode referral code\n    //  */\n    // function openPositionWithReferral(\n    //     IAmm _amm,\n    //     Side _side,\n    //     Decimal.decimal calldata _quoteAssetAmount,\n    //     Decimal.decimal calldata _leverage,\n    //     Decimal.decimal calldata _baseAssetAmountLimit,\n    //     bytes32 _referralCode\n    // ) external {\n    //     openPosition(_amm, _side, _quoteAssetAmount, _leverage, _baseAssetAmountLimit);\n    //     // if (_referralCode != 0) {\n    //     //     emit ReferredPositionChanged(_referralCode);\n    //     // }\n    // }\n\n    /**\n     * @notice open a position\n     * @param _amm amm address\n     * @param _side enum Side; BUY for long and SELL for short\n     * @param _quoteAssetAmount quote asset amount in 18 digits. Can Not be 0\n     * @param _leverage leverage  in 18 digits. Can Not be 0\n     * @param _baseAssetAmountLimit minimum base asset amount expected to get to prevent from slippage.\n     */\n    function openPosition(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit\n    ) public whenNotPaused() nonReentrant() {\n        requireAmm(_amm, true);\n        IERC20 quoteToken = _amm.quoteAsset();\n        requireValidTokenAmount(quoteToken, _quoteAssetAmount);\n        requireNonZeroInput(_leverage);\n        requireMoreMarginRatio(MixedDecimal.fromDecimal(Decimal.one()).divD(_leverage), initMarginRatio, true);\n        requireNotRestrictionMode(_amm);\n\n        address trader = _msgSender();\n        PositionResp memory positionResp;\n        {\n            // add scope for stack too deep error\n            int256 oldPositionSize = getPosition(_amm, trader).size.toInt();\n            bool isNewPosition = oldPositionSize == 0 ? true : false;\n\n            // increase or decrease position depends on old position's side and size\n            if (isNewPosition || (oldPositionSize > 0 ? Side.BUY : Side.SELL) == _side) {\n                positionResp = internalIncreasePosition(\n                    _amm,\n                    _side,\n                    _quoteAssetAmount.mulD(_leverage),\n                    _baseAssetAmountLimit,\n                    _leverage\n                );\n            } else {\n                positionResp = openReversePosition(\n                    _amm,\n                    _side,\n                    trader,\n                    _quoteAssetAmount,\n                    _leverage,\n                    _baseAssetAmountLimit,\n                    false\n                );\n            }\n\n            // update the position state\n            setPosition(_amm, trader, positionResp.position);\n            // if opening the exact position size as the existing one == closePosition, can skip the margin ratio check\n            if (!isNewPosition && positionResp.position.size.toInt() != 0) {\n                requireMoreMarginRatio(getMarginRatio(_amm, trader), maintenanceMarginRatio, true);\n            }\n\n            // to prevent attacker to leverage the bad debt to withdraw extra token from insurance fund\n            require(positionResp.badDebt.toUint() == 0, \"bad debt\");\n\n            // transfer the actual token between trader and vault\n            if (positionResp.marginToVault.toInt() > 0) {\n                _transferFrom(quoteToken, trader, address(this), positionResp.marginToVault.abs());\n            } else if (positionResp.marginToVault.toInt() < 0) {\n                withdraw(quoteToken, trader, positionResp.marginToVault.abs());\n            }\n        }\n\n        // calculate fee and transfer token for fees\n        //@audit - can optimize by changing amm.swapInput/swapOutput's return type to (exchangedAmount, quoteToll, quoteSpread, quoteReserve, baseReserve) (@wraecca)\n        Decimal.decimal memory transferredFee = transferFee(trader, _amm, positionResp.exchangedQuoteAssetAmount);\n\n        // emit event\n        uint256 spotPrice = _amm.getSpotPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt(); // pre-fetch for stack too deep error\n        emit PositionChanged(\n            trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            transferredFee.toUint(),\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            0,\n            spotPrice,\n            fundingPayment\n        );\n    }\n\n    // /**\n    //  * @notice close position with referral code\n    //  * @param _amm IAmm address\n    //  * @param _referralCode referral code\n    //  */\n    // function closePositionWithReferral(\n    //     IAmm _amm,\n    //     Decimal.decimal calldata _quoteAssetAmountLimit,\n    //     bytes32 _referralCode\n    // ) external {\n    //     closePosition(_amm, _quoteAssetAmountLimit);\n    //     // if (_referralCode != 0) {\n    //     //     emit ReferredPositionChanged(_referralCode);\n    //     // }\n    // }\n\n    /**\n     * @notice close all the positions\n     * @param _amm IAmm address\n     */\n    function closePosition(IAmm _amm, Decimal.decimal memory _quoteAssetAmountLimit)\n        public\n        whenNotPaused()\n        nonReentrant()\n    {\n        // check conditions\n        requireAmm(_amm, true);\n        requireNotRestrictionMode(_amm);\n\n        // update position\n        address trader = _msgSender();\n\n        PositionResp memory positionResp;\n        {\n            Position memory position = getPosition(_amm, trader);\n            // if it is long position, close a position means short it(which means base dir is ADD_TO_AMM) and vice versa\n            IAmm.Dir dirOfBase = position.size.toInt() > 0 ? IAmm.Dir.ADD_TO_AMM : IAmm.Dir.REMOVE_FROM_AMM;\n\n            // check if this position exceed fluctuation limit\n            // if over fluctuation limit, then close partial position. Otherwise close all.\n            // if partialLiquidationRatio is 1, then close whole position\n            if (\n                _amm.isOverFluctuationLimit(dirOfBase, position.size.abs()) &&\n                partialLiquidationRatio.cmp(Decimal.one()) < 0\n            ) {\n                Decimal.decimal memory partiallyClosedPositionNotional =\n                    _amm.getOutputPrice(dirOfBase, position.size.mulD(partialLiquidationRatio).abs());\n\n                positionResp = openReversePosition(\n                    _amm,\n                    position.size.toInt() > 0 ? Side.SELL : Side.BUY,\n                    trader,\n                    partiallyClosedPositionNotional,\n                    Decimal.one(),\n                    Decimal.zero(),\n                    true\n                );\n                setPosition(_amm, trader, positionResp.position);\n            } else {\n                positionResp = internalClosePosition(_amm, trader, _quoteAssetAmountLimit);\n            }\n\n            // to prevent attacker to leverage the bad debt to withdraw extra token from insurance fund\n            require(positionResp.badDebt.toUint() == 0, \"bad debt\");\n\n            // add scope for stack too deep error\n            // transfer the actual token from trader and vault\n            IERC20 quoteToken = _amm.quoteAsset();\n            withdraw(quoteToken, trader, positionResp.marginToVault.abs());\n        }\n\n        // calculate fee and transfer token for fees\n        Decimal.decimal memory transferredFee = transferFee(trader, _amm, positionResp.exchangedQuoteAssetAmount);\n\n        // prepare event\n        uint256 spotPrice = _amm.getSpotPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt();\n        emit PositionChanged(\n            trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            transferredFee.toUint(),\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            0,\n            spotPrice,\n            fundingPayment\n        );\n    }\n\n    function liquidateWithSlippage(\n        IAmm _amm,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) external nonReentrant() returns (Decimal.decimal memory quoteAssetAmount, bool isPartialClose) {\n        Position memory position = getPosition(_amm, _trader);\n        (quoteAssetAmount, isPartialClose) = internalLiquidate(_amm, _trader);\n\n        Decimal.decimal memory quoteAssetAmountLimit =\n            isPartialClose ? _quoteAssetAmountLimit.mulD(partialLiquidationRatio) : _quoteAssetAmountLimit;\n\n        if (position.size.toInt() > 0) {\n            require(quoteAssetAmount.toUint() >= quoteAssetAmountLimit.toUint(), \"Less than minimal quote token\");\n        } else if (position.size.toInt() < 0 && quoteAssetAmountLimit.cmp(Decimal.zero()) != 0) {\n            require(quoteAssetAmount.toUint() <= quoteAssetAmountLimit.toUint(), \"More than maximal quote token\");\n        }\n\n        return (quoteAssetAmount, isPartialClose);\n    }\n\n    /**\n     * @notice liquidate trader's underwater position. Require trader's margin ratio less than maintenance margin ratio\n     * @dev liquidator can NOT open any positions in the same block to prevent from price manipulation.\n     * @param _amm IAmm address\n     * @param _trader trader address\n     */\n    function liquidate(IAmm _amm, address _trader) public nonReentrant() {\n        internalLiquidate(_amm, _trader);\n    }\n\n    /**\n     * @notice if funding rate is positive, traders with long position pay traders with short position and vice versa.\n     * @param _amm IAmm address\n     */\n    function payFunding(IAmm _amm) external {\n        requireAmm(_amm, true);\n\n        SignedDecimal.signedDecimal memory premiumFraction = _amm.settleFunding();\n        ammMap[address(_amm)].cumulativePremiumFractions.push(\n            premiumFraction.addD(getLatestCumulativePremiumFraction(_amm))\n        );\n\n        // funding payment = premium fraction * position\n        // eg. if alice takes 10 long position, totalPositionSize = 10\n        // if premiumFraction is positive: long pay short, amm get positive funding payment\n        // if premiumFraction is negative: short pay long, amm get negative funding payment\n        // if totalPositionSize.side * premiumFraction > 0, funding payment is positive which means profit\n        SignedDecimal.signedDecimal memory totalTraderPositionSize = _amm.getBaseAssetDelta();\n        SignedDecimal.signedDecimal memory ammFundingPaymentProfit = premiumFraction.mulD(totalTraderPositionSize);\n\n        IERC20 quoteAsset = _amm.quoteAsset();\n        if (ammFundingPaymentProfit.toInt() < 0) {\n            insuranceFund.withdraw(quoteAsset, ammFundingPaymentProfit.abs());\n        } else {\n            transferToInsuranceFund(quoteAsset, ammFundingPaymentProfit.abs());\n        }\n    }\n\n    //\n    // VIEW FUNCTIONS\n    //\n\n    /**\n     * @notice get margin ratio, marginRatio = (margin + funding payment + unrealized Pnl) / positionNotional\n     * use spot and twap price to calculate unrealized Pnl, final unrealized Pnl depends on which one is higher\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return margin ratio in 18 digits\n     */\n    function getMarginRatio(IAmm _amm, address _trader) public view returns (SignedDecimal.signedDecimal memory) {\n        Position memory position = getPosition(_amm, _trader);\n        requirePositionSize(position.size);\n        (SignedDecimal.signedDecimal memory unrealizedPnl, Decimal.decimal memory positionNotional) =\n            getPreferencePositionNotionalAndUnrealizedPnl(_amm, _trader, PnlPreferenceOption.MAX_PNL);\n        return _getMarginRatio(_amm, position, unrealizedPnl, positionNotional);\n    }\n\n    function _getMarginRatioByCalcOption(\n        IAmm _amm,\n        address _trader,\n        PnlCalcOption _pnlCalcOption\n    ) internal view returns (SignedDecimal.signedDecimal memory) {\n        Position memory position = getPosition(_amm, _trader);\n        requirePositionSize(position.size);\n        (Decimal.decimal memory positionNotional, SignedDecimal.signedDecimal memory pnl) =\n            getPositionNotionalAndUnrealizedPnl(_amm, _trader, _pnlCalcOption);\n        return _getMarginRatio(_amm, position, pnl, positionNotional);\n    }\n\n    function _getMarginRatio(\n        IAmm _amm,\n        Position memory _position,\n        SignedDecimal.signedDecimal memory _unrealizedPnl,\n        Decimal.decimal memory _positionNotional\n    ) internal view returns (SignedDecimal.signedDecimal memory) {\n        (Decimal.decimal memory remainMargin, Decimal.decimal memory badDebt, , ) =\n            calcRemainMarginWithFundingPayment(_amm, _position, _unrealizedPnl);\n        return MixedDecimal.fromDecimal(remainMargin).subD(badDebt).divD(_positionNotional);\n    }\n\n    /**\n     * @notice get personal position information\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return struct Position\n     */\n    function getPosition(IAmm _amm, address _trader) public view returns (Position memory) {\n        return ammMap[address(_amm)].positionMap[_trader];\n    }\n\n    /**\n     * @notice get position notional and unrealized Pnl without fee expense and funding payment\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @param _pnlCalcOption enum PnlCalcOption, SPOT_PRICE for spot price and TWAP for twap price\n     * @return positionNotional position notional\n     * @return unrealizedPnl unrealized Pnl\n     */\n    function getPositionNotionalAndUnrealizedPnl(\n        IAmm _amm,\n        address _trader,\n        PnlCalcOption _pnlCalcOption\n    ) public view returns (Decimal.decimal memory positionNotional, SignedDecimal.signedDecimal memory unrealizedPnl) {\n        Position memory position = getPosition(_amm, _trader);\n        Decimal.decimal memory positionSizeAbs = position.size.abs();\n        if (positionSizeAbs.toUint() != 0) {\n            bool isShortPosition = position.size.toInt() < 0;\n            IAmm.Dir dir = isShortPosition ? IAmm.Dir.REMOVE_FROM_AMM : IAmm.Dir.ADD_TO_AMM;\n            if (_pnlCalcOption == PnlCalcOption.TWAP) {\n                positionNotional = _amm.getOutputTwap(dir, positionSizeAbs);\n            } else if (_pnlCalcOption == PnlCalcOption.SPOT_PRICE) {\n                positionNotional = _amm.getOutputPrice(dir, positionSizeAbs);\n            } else {\n                Decimal.decimal memory oraclePrice = _amm.getUnderlyingPrice();\n                positionNotional = positionSizeAbs.mulD(oraclePrice);\n            }\n            // unrealizedPnlForLongPosition = positionNotional - openNotional\n            // unrealizedPnlForShortPosition = positionNotionalWhenBorrowed - positionNotionalWhenReturned =\n            // openNotional - positionNotional = unrealizedPnlForLongPosition * -1\n            unrealizedPnl = isShortPosition\n                ? MixedDecimal.fromDecimal(position.openNotional).subD(positionNotional)\n                : MixedDecimal.fromDecimal(positionNotional).subD(position.openNotional);\n        }\n    }\n\n    /**\n     * @notice get latest cumulative premium fraction.\n     * @param _amm IAmm address\n     * @return latest cumulative premium fraction in 18 digits\n     */\n    function getLatestCumulativePremiumFraction(IAmm _amm) public view returns (SignedDecimal.signedDecimal memory) {\n        uint256 len = ammMap[address(_amm)].cumulativePremiumFractions.length;\n        if (len > 0) {\n            return ammMap[address(_amm)].cumulativePremiumFractions[len - 1];\n        }\n    }\n\n    //\n    // INTERNAL FUNCTIONS\n    //\n\n    function enterRestrictionMode(IAmm _amm) internal {\n        uint256 blockNumber = _blockNumber();\n        ammMap[address(_amm)].lastRestrictionBlock = blockNumber;\n        emit RestrictionModeEntered(address(_amm), blockNumber);\n    }\n\n    function setPosition(\n        IAmm _amm,\n        address _trader,\n        Position memory _position\n    ) internal {\n        Position storage positionStorage = ammMap[address(_amm)].positionMap[_trader];\n        positionStorage.size = _position.size;\n        positionStorage.margin = _position.margin;\n        positionStorage.openNotional = _position.openNotional;\n        positionStorage.lastUpdatedCumulativePremiumFraction = _position.lastUpdatedCumulativePremiumFraction;\n        positionStorage.blockNumber = _position.blockNumber;\n        positionStorage.liquidityHistoryIndex = _position.liquidityHistoryIndex;\n    }\n\n    function clearPosition(IAmm _amm, address _trader) internal {\n        // keep the record in order to retain the last updated block number\n        ammMap[address(_amm)].positionMap[_trader] = Position({\n            size: SignedDecimal.zero(),\n            margin: Decimal.zero(),\n            openNotional: Decimal.zero(),\n            lastUpdatedCumulativePremiumFraction: SignedDecimal.zero(),\n            blockNumber: _blockNumber(),\n            liquidityHistoryIndex: 0\n        });\n    }\n\n    function internalLiquidate(IAmm _amm, address _trader)\n        internal\n        returns (Decimal.decimal memory quoteAssetAmount, bool isPartialClose)\n    {\n        requireAmm(_amm, true);\n        SignedDecimal.signedDecimal memory marginRatio = getMarginRatio(_amm, _trader);\n\n        // including oracle-based margin ratio as reference price when amm is over spread limit\n        if (_amm.isOverSpreadLimit()) {\n            SignedDecimal.signedDecimal memory marginRatioBasedOnOracle =\n                _getMarginRatioByCalcOption(_amm, _trader, PnlCalcOption.ORACLE);\n            if (marginRatioBasedOnOracle.subD(marginRatio).toInt() > 0) {\n                marginRatio = marginRatioBasedOnOracle;\n            }\n        }\n        requireMoreMarginRatio(marginRatio, maintenanceMarginRatio, false);\n\n        PositionResp memory positionResp;\n        Decimal.decimal memory liquidationPenalty;\n        {\n            Decimal.decimal memory liquidationBadDebt;\n            Decimal.decimal memory feeToLiquidator;\n            Decimal.decimal memory feeToInsuranceFund;\n            IERC20 quoteAsset = _amm.quoteAsset();\n\n            int256 marginRatioBasedOnSpot =\n                _getMarginRatioByCalcOption(_amm, _trader, PnlCalcOption.SPOT_PRICE).toInt();\n            if (\n                // check margin(based on spot price) is enough to pay the liquidation fee\n                // after partially close, otherwise we fully close the position.\n                // that also means we can ensure no bad debt happen when partially liquidate\n                marginRatioBasedOnSpot > int256(liquidationFeeRatio.toUint()) &&\n                partialLiquidationRatio.cmp(Decimal.one()) < 0 &&\n                partialLiquidationRatio.toUint() != 0\n            ) {\n                Position memory position = getPosition(_amm, _trader);\n                Decimal.decimal memory partiallyLiquidatedPositionNotional =\n                    _amm.getOutputPrice(\n                        position.size.toInt() > 0 ? IAmm.Dir.ADD_TO_AMM : IAmm.Dir.REMOVE_FROM_AMM,\n                        position.size.mulD(partialLiquidationRatio).abs()\n                    );\n\n                positionResp = openReversePosition(\n                    _amm,\n                    position.size.toInt() > 0 ? Side.SELL : Side.BUY,\n                    _trader,\n                    partiallyLiquidatedPositionNotional,\n                    Decimal.one(),\n                    Decimal.zero(),\n                    true\n                );\n\n                // half of the liquidationFee goes to liquidator & another half goes to insurance fund\n                liquidationPenalty = positionResp.exchangedQuoteAssetAmount.mulD(liquidationFeeRatio);\n                feeToLiquidator = liquidationPenalty.divScalar(2);\n                feeToInsuranceFund = liquidationPenalty.subD(feeToLiquidator);\n\n                positionResp.position.margin = positionResp.position.margin.subD(liquidationPenalty);\n                setPosition(_amm, _trader, positionResp.position);\n\n                isPartialClose = true;\n            } else {\n                liquidationPenalty = getPosition(_amm, _trader).margin;\n                positionResp = internalClosePosition(_amm, _trader, Decimal.zero());\n                Decimal.decimal memory remainMargin = positionResp.marginToVault.abs();\n                feeToLiquidator = positionResp.exchangedQuoteAssetAmount.mulD(liquidationFeeRatio).divScalar(2);\n\n                // if the remainMargin is not enough for liquidationFee, count it as bad debt\n                // else, then the rest will be transferred to insuranceFund\n                Decimal.decimal memory totalBadDebt = positionResp.badDebt;\n                if (feeToLiquidator.toUint() > remainMargin.toUint()) {\n                    liquidationBadDebt = feeToLiquidator.subD(remainMargin);\n                    totalBadDebt = totalBadDebt.addD(liquidationBadDebt);\n                } else {\n                    remainMargin = remainMargin.subD(feeToLiquidator);\n                }\n\n                // transfer the actual token between trader and vault\n                if (totalBadDebt.toUint() > 0) {\n                    require(backstopLiquidityProviderMap[_msgSender()], \"not backstop LP\");\n                    realizeBadDebt(quoteAsset, totalBadDebt);\n                }\n                if (remainMargin.toUint() > 0) {\n                    feeToInsuranceFund = remainMargin;\n                }\n            }\n\n            if (feeToInsuranceFund.toUint() > 0) {\n                transferToInsuranceFund(quoteAsset, feeToInsuranceFund);\n            }\n            withdraw(quoteAsset, _msgSender(), feeToLiquidator);\n            enterRestrictionMode(_amm);\n\n            emit PositionLiquidated(\n                _trader,\n                address(_amm),\n                positionResp.exchangedQuoteAssetAmount.toUint(),\n                positionResp.exchangedPositionSize.toUint(),\n                feeToLiquidator.toUint(),\n                _msgSender(),\n                liquidationBadDebt.toUint()\n            );\n        }\n\n        // emit event\n        uint256 spotPrice = _amm.getSpotPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt();\n        emit PositionChanged(\n            _trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            0,\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            liquidationPenalty.toUint(),\n            spotPrice,\n            fundingPayment\n        );\n\n        return (positionResp.exchangedQuoteAssetAmount, isPartialClose);\n    }\n\n    // only called from openPosition and closeAndOpenReversePosition. caller need to ensure there's enough marginRatio\n    function internalIncreasePosition(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal memory _openNotional,\n        Decimal.decimal memory _minPositionSize,\n        Decimal.decimal memory _leverage\n    ) internal returns (PositionResp memory positionResp) {\n        address trader = _msgSender();\n        Position memory oldPosition = getPosition(_amm, trader);\n        positionResp.exchangedPositionSize = swapInput(_amm, _side, _openNotional, _minPositionSize, false);\n        SignedDecimal.signedDecimal memory newSize = oldPosition.size.addD(positionResp.exchangedPositionSize);\n\n        updateOpenInterestNotional(_amm, MixedDecimal.fromDecimal(_openNotional));\n        // if the trader is not in the whitelist, check max position size\n        if (trader != whitelist) {\n            Decimal.decimal memory maxHoldingBaseAsset = _amm.getMaxHoldingBaseAsset();\n            if (maxHoldingBaseAsset.toUint() > 0) {\n                // total position size should be less than `positionUpperBound`\n                require(newSize.abs().cmp(maxHoldingBaseAsset) <= 0, \"hit position size upper bound\");\n            }\n        }\n\n        SignedDecimal.signedDecimal memory increaseMarginRequirement =\n            MixedDecimal.fromDecimal(_openNotional.divD(_leverage));\n        (\n            Decimal.decimal memory remainMargin, // the 2nd return (bad debt) must be 0 - already checked from caller\n            ,\n            SignedDecimal.signedDecimal memory fundingPayment,\n            SignedDecimal.signedDecimal memory latestCumulativePremiumFraction\n        ) = calcRemainMarginWithFundingPayment(_amm, oldPosition, increaseMarginRequirement);\n\n        (, SignedDecimal.signedDecimal memory unrealizedPnl) =\n            getPositionNotionalAndUnrealizedPnl(_amm, trader, PnlCalcOption.SPOT_PRICE);\n\n        // update positionResp\n        positionResp.exchangedQuoteAssetAmount = _openNotional;\n        positionResp.unrealizedPnlAfter = unrealizedPnl;\n        positionResp.marginToVault = increaseMarginRequirement;\n        positionResp.fundingPayment = fundingPayment;\n        positionResp.position = Position(\n            newSize,\n            remainMargin,\n            oldPosition.openNotional.addD(positionResp.exchangedQuoteAssetAmount),\n            latestCumulativePremiumFraction,\n            oldPosition.liquidityHistoryIndex,\n            _blockNumber()\n        );\n    }\n\n    function openReversePosition(\n        IAmm _amm,\n        Side _side,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit,\n        bool _canOverFluctuationLimit\n    ) internal returns (PositionResp memory) {\n        Decimal.decimal memory openNotional = _quoteAssetAmount.mulD(_leverage);\n        (Decimal.decimal memory oldPositionNotional, SignedDecimal.signedDecimal memory unrealizedPnl) =\n            getPositionNotionalAndUnrealizedPnl(_amm, _trader, PnlCalcOption.SPOT_PRICE);\n        PositionResp memory positionResp;\n\n        // reduce position if old position is larger\n        if (oldPositionNotional.toUint() > openNotional.toUint()) {\n            updateOpenInterestNotional(_amm, MixedDecimal.fromDecimal(openNotional).mulScalar(-1));\n            Position memory oldPosition = getPosition(_amm, _trader);\n            positionResp.exchangedPositionSize = swapInput(\n                _amm,\n                _side,\n                openNotional,\n                _baseAssetAmountLimit,\n                _canOverFluctuationLimit\n            );\n\n            // realizedPnl = unrealizedPnl * closedRatio\n            // closedRatio = positionResp.exchangedPositionSiz / oldPosition.size\n            if (oldPosition.size.toInt() != 0) {\n                positionResp.realizedPnl = unrealizedPnl.mulD(positionResp.exchangedPositionSize.abs()).divD(\n                    oldPosition.size.abs()\n                );\n            }\n            Decimal.decimal memory remainMargin;\n            SignedDecimal.signedDecimal memory latestCumulativePremiumFraction;\n            (\n                remainMargin,\n                positionResp.badDebt,\n                positionResp.fundingPayment,\n                latestCumulativePremiumFraction\n            ) = calcRemainMarginWithFundingPayment(_amm, oldPosition, positionResp.realizedPnl);\n\n            // positionResp.unrealizedPnlAfter = unrealizedPnl - realizedPnl\n            positionResp.unrealizedPnlAfter = unrealizedPnl.subD(positionResp.realizedPnl);\n            positionResp.exchangedQuoteAssetAmount = openNotional;\n\n            // calculate openNotional (it's different depends on long or short side)\n            // long: unrealizedPnl = positionNotional - openNotional => openNotional = positionNotional - unrealizedPnl\n            // short: unrealizedPnl = openNotional - positionNotional => openNotional = positionNotional + unrealizedPnl\n            // positionNotional = oldPositionNotional - exchangedQuoteAssetAmount\n            SignedDecimal.signedDecimal memory remainOpenNotional =\n                oldPosition.size.toInt() > 0\n                    ? MixedDecimal.fromDecimal(oldPositionNotional).subD(positionResp.exchangedQuoteAssetAmount).subD(\n                        positionResp.unrealizedPnlAfter\n                    )\n                    : positionResp.unrealizedPnlAfter.addD(oldPositionNotional).subD(\n                        positionResp.exchangedQuoteAssetAmount\n                    );\n            require(remainOpenNotional.toInt() > 0, \"value of openNotional <= 0\");\n\n            positionResp.position = Position(\n                oldPosition.size.addD(positionResp.exchangedPositionSize),\n                remainMargin,\n                remainOpenNotional.abs(),\n                latestCumulativePremiumFraction,\n                oldPosition.liquidityHistoryIndex,\n                _blockNumber()\n            );\n            return positionResp;\n        }\n\n        return closeAndOpenReversePosition(_amm, _side, _trader, _quoteAssetAmount, _leverage, _baseAssetAmountLimit);\n    }\n\n    function closeAndOpenReversePosition(\n        IAmm _amm,\n        Side _side,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit\n    ) internal returns (PositionResp memory positionResp) {\n        // new position size is larger than or equal to the old position size\n        // so either close or close then open a larger position\n        PositionResp memory closePositionResp = internalClosePosition(_amm, _trader, Decimal.zero());\n\n        // the old position is underwater. trader should close a position first\n        require(closePositionResp.badDebt.toUint() == 0, \"reduce an underwater position\");\n\n        // update open notional after closing position\n        Decimal.decimal memory openNotional =\n            _quoteAssetAmount.mulD(_leverage).subD(closePositionResp.exchangedQuoteAssetAmount);\n\n        // if remain exchangedQuoteAssetAmount is too small (eg. 1wei) then the required margin might be 0\n        // then the clearingHouse will stop opening position\n        if (openNotional.divD(_leverage).toUint() == 0) {\n            positionResp = closePositionResp;\n        } else {\n            Decimal.decimal memory updatedBaseAssetAmountLimit;\n            if (_baseAssetAmountLimit.toUint() > closePositionResp.exchangedPositionSize.toUint()) {\n                updatedBaseAssetAmountLimit = _baseAssetAmountLimit.subD(closePositionResp.exchangedPositionSize.abs());\n            }\n\n            PositionResp memory increasePositionResp =\n                internalIncreasePosition(_amm, _side, openNotional, updatedBaseAssetAmountLimit, _leverage);\n            positionResp = PositionResp({\n                position: increasePositionResp.position,\n                exchangedQuoteAssetAmount: closePositionResp.exchangedQuoteAssetAmount.addD(\n                    increasePositionResp.exchangedQuoteAssetAmount\n                ),\n                badDebt: closePositionResp.badDebt.addD(increasePositionResp.badDebt),\n                fundingPayment: closePositionResp.fundingPayment.addD(increasePositionResp.fundingPayment),\n                exchangedPositionSize: closePositionResp.exchangedPositionSize.addD(\n                    increasePositionResp.exchangedPositionSize\n                ),\n                realizedPnl: closePositionResp.realizedPnl.addD(increasePositionResp.realizedPnl),\n                unrealizedPnlAfter: SignedDecimal.zero(),\n                marginToVault: closePositionResp.marginToVault.addD(increasePositionResp.marginToVault)\n            });\n        }\n        return positionResp;\n    }\n\n    function internalClosePosition(\n        IAmm _amm,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) private returns (PositionResp memory positionResp) {\n        // check conditions\n        Position memory oldPosition = getPosition(_amm, _trader);\n        requirePositionSize(oldPosition.size);\n\n        (, SignedDecimal.signedDecimal memory unrealizedPnl) =\n            getPositionNotionalAndUnrealizedPnl(_amm, _trader, PnlCalcOption.SPOT_PRICE);\n        (\n            Decimal.decimal memory remainMargin,\n            Decimal.decimal memory badDebt,\n            SignedDecimal.signedDecimal memory fundingPayment,\n\n        ) = calcRemainMarginWithFundingPayment(_amm, oldPosition, unrealizedPnl);\n\n        positionResp.exchangedPositionSize = oldPosition.size.mulScalar(-1);\n        positionResp.realizedPnl = unrealizedPnl;\n        positionResp.badDebt = badDebt;\n        positionResp.fundingPayment = fundingPayment;\n        positionResp.marginToVault = MixedDecimal.fromDecimal(remainMargin).mulScalar(-1);\n        // for amm.swapOutput, the direction is in base asset, from the perspective of Amm\n        positionResp.exchangedQuoteAssetAmount = _amm.swapOutput(\n            oldPosition.size.toInt() > 0 ? IAmm.Dir.ADD_TO_AMM : IAmm.Dir.REMOVE_FROM_AMM,\n            oldPosition.size.abs(),\n            _quoteAssetAmountLimit\n        );\n\n        // bankrupt position's bad debt will be also consider as a part of the open interest\n        updateOpenInterestNotional(_amm, unrealizedPnl.addD(badDebt).addD(oldPosition.openNotional).mulScalar(-1));\n        clearPosition(_amm, _trader);\n    }\n\n    function swapInput(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal memory _inputAmount,\n        Decimal.decimal memory _minOutputAmount,\n        bool _canOverFluctuationLimit\n    ) internal returns (SignedDecimal.signedDecimal memory) {\n        // for amm.swapInput, the direction is in quote asset, from the perspective of Amm\n        IAmm.Dir dir = (_side == Side.BUY) ? IAmm.Dir.ADD_TO_AMM : IAmm.Dir.REMOVE_FROM_AMM;\n        SignedDecimal.signedDecimal memory outputAmount =\n            MixedDecimal.fromDecimal(_amm.swapInput(dir, _inputAmount, _minOutputAmount, _canOverFluctuationLimit));\n        if (IAmm.Dir.REMOVE_FROM_AMM == dir) {\n            return outputAmount.mulScalar(-1);\n        }\n        return outputAmount;\n    }\n\n    function transferFee(\n        address _from,\n        IAmm _amm,\n        Decimal.decimal memory _positionNotional\n    ) internal returns (Decimal.decimal memory) {\n        // the logic of toll fee can be removed if the bytecode size is too large\n        (Decimal.decimal memory toll, Decimal.decimal memory spread) = _amm.calcFee(_positionNotional);\n        bool hasToll = toll.toUint() > 0;\n        bool hasSpread = spread.toUint() > 0;\n        if (hasToll || hasSpread) {\n            IERC20 quoteAsset = _amm.quoteAsset();\n\n            // transfer spread to insurance fund\n            if (hasSpread) {\n                _transferFrom(quoteAsset, _from, address(insuranceFund), spread);\n            }\n\n            // transfer toll to feePool\n            if (hasToll) {\n                require(address(feePool) != address(0), \"Invalid feePool\");\n                _transferFrom(quoteAsset, _from, address(feePool), toll);\n                feePool.notifyTokenAmount(quoteAsset, toll);\n            }\n\n            // fee = spread + toll\n            return toll.addD(spread);\n        }\n    }\n\n    function withdraw(\n        IERC20 _token,\n        address _receiver,\n        Decimal.decimal memory _amount\n    ) internal {\n        // if withdraw amount is larger than entire balance of vault\n        // means this trader's profit comes from other under collateral position's future loss\n        // and the balance of entire vault is not enough\n        // need money from IInsuranceFund to pay first, and record this prepaidBadDebt\n        // in this case, insurance fund loss must be zero\n        Decimal.decimal memory totalTokenBalance = _balanceOf(_token, address(this));\n        if (totalTokenBalance.toUint() < _amount.toUint()) {\n            Decimal.decimal memory balanceShortage = _amount.subD(totalTokenBalance);\n            prepaidBadDebt[address(_token)] = prepaidBadDebt[address(_token)].addD(balanceShortage);\n            insuranceFund.withdraw(_token, balanceShortage);\n        }\n\n        _transfer(_token, _receiver, _amount);\n    }\n\n    function realizeBadDebt(IERC20 _token, Decimal.decimal memory _badDebt) internal {\n        Decimal.decimal memory badDebtBalance = prepaidBadDebt[address(_token)];\n        if (badDebtBalance.toUint() > _badDebt.toUint()) {\n            // no need to move extra tokens because vault already prepay bad debt, only need to update the numbers\n            prepaidBadDebt[address(_token)] = badDebtBalance.subD(_badDebt);\n        } else {\n            // in order to realize all the bad debt vault need extra tokens from insuranceFund\n            insuranceFund.withdraw(_token, _badDebt.subD(badDebtBalance));\n            prepaidBadDebt[address(_token)] = Decimal.zero();\n        }\n    }\n\n    function transferToInsuranceFund(IERC20 _token, Decimal.decimal memory _amount) internal {\n        Decimal.decimal memory totalTokenBalance = _balanceOf(_token, address(this));\n        _transfer(\n            _token,\n            address(insuranceFund),\n            totalTokenBalance.toUint() < _amount.toUint() ? totalTokenBalance : _amount\n        );\n    }\n\n    /**\n     * @dev assume this will be removes soon once the guarded period has ended. caller need to ensure amm exist\n     */\n    function updateOpenInterestNotional(IAmm _amm, SignedDecimal.signedDecimal memory _amount) internal {\n        // when cap = 0 means no cap\n        uint256 cap = _amm.getOpenInterestNotionalCap().toUint();\n        address ammAddr = address(_amm);\n        if (cap > 0) {\n            SignedDecimal.signedDecimal memory updatedOpenInterestNotional =\n                _amount.addD(openInterestNotionalMap[ammAddr]);\n            // the reduced open interest can be larger than total when profit is too high and other position are bankrupt\n            if (updatedOpenInterestNotional.toInt() < 0) {\n                updatedOpenInterestNotional = SignedDecimal.zero();\n            }\n            if (_amount.toInt() > 0) {\n                // whitelist won't be restrict by open interest cap\n                require(updatedOpenInterestNotional.toUint() <= cap || _msgSender() == whitelist, \"over limit\");\n            }\n            openInterestNotionalMap[ammAddr] = updatedOpenInterestNotional.abs();\n        }\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function calcRemainMarginWithFundingPayment(\n        IAmm _amm,\n        Position memory _oldPosition,\n        SignedDecimal.signedDecimal memory _marginDelta\n    )\n        private\n        view\n        returns (\n            Decimal.decimal memory remainMargin,\n            Decimal.decimal memory badDebt,\n            SignedDecimal.signedDecimal memory fundingPayment,\n            SignedDecimal.signedDecimal memory latestCumulativePremiumFraction\n        )\n    {\n        // calculate funding payment\n        latestCumulativePremiumFraction = getLatestCumulativePremiumFraction(_amm);\n        if (_oldPosition.size.toInt() != 0) {\n            fundingPayment = latestCumulativePremiumFraction\n                .subD(_oldPosition.lastUpdatedCumulativePremiumFraction)\n                .mulD(_oldPosition.size);\n        }\n\n        // calculate remain margin\n        SignedDecimal.signedDecimal memory signedRemainMargin =\n            _marginDelta.subD(fundingPayment).addD(_oldPosition.margin);\n\n        // if remain margin is negative, set to zero and leave the rest to bad debt\n        if (signedRemainMargin.toInt() < 0) {\n            badDebt = signedRemainMargin.abs();\n        } else {\n            remainMargin = signedRemainMargin.abs();\n        }\n    }\n\n    /// @param _marginWithFundingPayment margin + funding payment - bad debt\n    function calcFreeCollateral(\n        IAmm _amm,\n        address _trader,\n        Decimal.decimal memory _marginWithFundingPayment\n    ) internal view returns (SignedDecimal.signedDecimal memory) {\n        Position memory pos = getPosition(_amm, _trader);\n        (SignedDecimal.signedDecimal memory unrealizedPnl, Decimal.decimal memory positionNotional) =\n            getPreferencePositionNotionalAndUnrealizedPnl(_amm, _trader, PnlPreferenceOption.MIN_PNL);\n\n        // min(margin + funding, margin + funding + unrealized PnL) - position value * initMarginRatio\n        SignedDecimal.signedDecimal memory accountValue = unrealizedPnl.addD(_marginWithFundingPayment);\n        SignedDecimal.signedDecimal memory minCollateral =\n            unrealizedPnl.toInt() > 0 ? MixedDecimal.fromDecimal(_marginWithFundingPayment) : accountValue;\n\n        // margin requirement\n        // if holding a long position, using open notional (mapping to quote debt in Curie)\n        // if holding a short position, using position notional (mapping to base debt in Curie)\n        SignedDecimal.signedDecimal memory marginRequirement =\n            pos.size.toInt() > 0\n                ? MixedDecimal.fromDecimal(pos.openNotional).mulD(initMarginRatio)\n                : MixedDecimal.fromDecimal(positionNotional).mulD(initMarginRatio);\n\n        return minCollateral.subD(marginRequirement);\n    }\n\n    function getPreferencePositionNotionalAndUnrealizedPnl(\n        IAmm _amm,\n        address _trader,\n        PnlPreferenceOption _pnlPreference\n    )\n        internal\n        view\n        returns (SignedDecimal.signedDecimal memory unrealizedPnl, Decimal.decimal memory positionNotional)\n    {\n        (Decimal.decimal memory spotPositionNotional, SignedDecimal.signedDecimal memory spotPricePnl) =\n            (getPositionNotionalAndUnrealizedPnl(_amm, _trader, PnlCalcOption.SPOT_PRICE));\n        (Decimal.decimal memory twapPositionNotional, SignedDecimal.signedDecimal memory twapPricePnl) =\n            (getPositionNotionalAndUnrealizedPnl(_amm, _trader, PnlCalcOption.TWAP));\n\n        // if MAX_PNL\n        //    spotPnL >  twapPnL return (spotPnL, spotPositionNotional)\n        //    spotPnL <= twapPnL return (twapPnL, twapPositionNotional)\n        // if MIN_PNL\n        //    spotPnL >  twapPnL return (twapPnL, twapPositionNotional)\n        //    spotPnL <= twapPnL return (spotPnL, spotPositionNotional)\n        (unrealizedPnl, positionNotional) = (_pnlPreference == PnlPreferenceOption.MAX_PNL) ==\n            (spotPricePnl.toInt() > twapPricePnl.toInt())\n            ? (spotPricePnl, spotPositionNotional)\n            : (twapPricePnl, twapPositionNotional);\n    }\n\n    function getUnadjustedPosition(IAmm _amm, address _trader) public view returns (Position memory position) {\n        position = ammMap[address(_amm)].positionMap[_trader];\n    }\n\n    function _msgSender() internal view override(BaseRelayRecipient, ContextUpgradeSafe) returns (address payable) {\n        return super._msgSender();\n    }\n\n    function _msgData() internal view override(BaseRelayRecipient, ContextUpgradeSafe) returns (bytes memory ret) {\n        return super._msgData();\n    }\n\n    //\n    // REQUIRE FUNCTIONS\n    //\n    function requireAmm(IAmm _amm, bool _open) private view {\n        require(insuranceFund.isExistedAmm(_amm), \"amm not found\");\n        require(_open == _amm.open(), _open ? \"amm was closed\" : \"amm is open\");\n    }\n\n    function requireNonZeroInput(Decimal.decimal memory _decimal) private pure {\n        require(_decimal.toUint() != 0, \"input is 0\");\n    }\n\n    function requirePositionSize(SignedDecimal.signedDecimal memory _size) private pure {\n        require(_size.toInt() != 0, \"positionSize is 0\");\n    }\n\n    function requireValidTokenAmount(IERC20 _token, Decimal.decimal memory _decimal) private view {\n        require(_toUint(_token, _decimal) != 0, \"invalid token amount\");\n    }\n\n    function requireNotRestrictionMode(IAmm _amm) private view {\n        uint256 currentBlock = _blockNumber();\n        if (currentBlock == ammMap[address(_amm)].lastRestrictionBlock) {\n            require(getPosition(_amm, _msgSender()).blockNumber != currentBlock, \"only one action allowed\");\n        }\n    }\n\n    function requireMoreMarginRatio(\n        SignedDecimal.signedDecimal memory _marginRatio,\n        Decimal.decimal memory _baseMarginRatio,\n        bool _largerThanOrEqualTo\n    ) private pure {\n        int256 remainingMarginRatio = _marginRatio.subD(_baseMarginRatio).toInt();\n        require(\n            _largerThanOrEqualTo ? remainingMarginRatio >= 0 : remainingMarginRatio < 0,\n            \"Margin ratio not meet criteria\"\n        );\n    }\n}\n"
    },
    "@opengsn/gsn/contracts/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\n// solhint-disable no-inline-assembly\npragma solidity ^0.6.2;\n\nimport \"./interfaces/IRelayRecipient.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient is IRelayRecipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address public trustedForwarder;\n\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, return the original sender.\n     * otherwise, return `msg.sender`.\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal override virtual view returns (address payable ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal override virtual view returns (bytes memory ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // we copy the msg.data , except the last 20 bytes (and update the total length)\n            assembly {\n                let ptr := mload(0x40)\n                // copy only size-20 bytes\n                let size := sub(calldatasize(),20)\n                // structure RLP data as <offset> <length> <bytes>\n                mstore(ptr, 0x20)\n                mstore(add(ptr,32), size)\n                calldatacopy(add(ptr,64), 0, size)\n                return(ptr, add(size,64))\n            }\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/utils/DecimalERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport {Decimal} from \"./Decimal.sol\";\n\nabstract contract DecimalERC20 {\n    using SafeMath for uint256;\n    using Decimal for Decimal.decimal;\n\n    mapping(address => uint256) private decimalMap;\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // INTERNAL functions\n    //\n\n    // CAUTION: do not input _from == _to s.t. this function will always fail\n    function _transfer(\n        IERC20 _token,\n        address _to,\n        Decimal.decimal memory _value\n    ) internal {\n        _updateDecimal(address(_token));\n        Decimal.decimal memory balanceBefore = _balanceOf(_token, _to);\n        uint256 roundedDownValue = _toUint(_token, _value);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(_token.transfer.selector, _to, roundedDownValue)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"DecimalERC20: transfer failed\"\n        );\n        _validateBalance(_token, _to, roundedDownValue, balanceBefore);\n    }\n\n    function _transferFrom(\n        IERC20 _token,\n        address _from,\n        address _to,\n        Decimal.decimal memory _value\n    ) internal {\n        _updateDecimal(address(_token));\n        Decimal.decimal memory balanceBefore = _balanceOf(_token, _to);\n        uint256 roundedDownValue = _toUint(_token, _value);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(_token.transferFrom.selector, _from, _to, roundedDownValue)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"DecimalERC20: transferFrom failed\"\n        );\n        _validateBalance(_token, _to, roundedDownValue, balanceBefore);\n    }\n\n    function _approve(\n        IERC20 _token,\n        address _spender,\n        Decimal.decimal memory _value\n    ) internal {\n        _updateDecimal(address(_token));\n        // to be compatible with some erc20 tokens like USDT\n        __approve(_token, _spender, Decimal.zero());\n        __approve(_token, _spender, _value);\n    }\n\n    //\n    // VIEW\n    //\n    function _allowance(\n        IERC20 _token,\n        address _owner,\n        address _spender\n    ) internal view returns (Decimal.decimal memory) {\n        return _toDecimal(_token, _token.allowance(_owner, _spender));\n    }\n\n    function _balanceOf(IERC20 _token, address _owner)\n        internal\n        view\n        returns (Decimal.decimal memory)\n    {\n        return _toDecimal(_token, _token.balanceOf(_owner));\n    }\n\n    function _totalSupply(IERC20 _token) internal view returns (Decimal.decimal memory) {\n        return _toDecimal(_token, _token.totalSupply());\n    }\n\n    function _toDecimal(IERC20 _token, uint256 _number)\n        internal\n        view\n        returns (Decimal.decimal memory)\n    {\n        uint256 tokenDecimals = _getTokenDecimals(address(_token));\n        if (tokenDecimals >= 18) {\n            return Decimal.decimal(_number.div(10**(tokenDecimals.sub(18))));\n        }\n\n        return Decimal.decimal(_number.mul(10**(uint256(18).sub(tokenDecimals))));\n    }\n\n    function _toUint(IERC20 _token, Decimal.decimal memory _decimal)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 tokenDecimals = _getTokenDecimals(address(_token));\n        if (tokenDecimals >= 18) {\n            return _decimal.toUint().mul(10**(tokenDecimals.sub(18)));\n        }\n        return _decimal.toUint().div(10**(uint256(18).sub(tokenDecimals)));\n    }\n\n    function _getTokenDecimals(address _token) internal view returns (uint256) {\n        uint256 tokenDecimals = decimalMap[_token];\n        if (tokenDecimals == 0) {\n            (bool success, bytes memory data) = _token.staticcall(\n                abi.encodeWithSignature(\"decimals()\")\n            );\n            require(success && data.length != 0, \"DecimalERC20: get decimals failed\");\n            tokenDecimals = abi.decode(data, (uint256));\n        }\n        return tokenDecimals;\n    }\n\n    //\n    // PRIVATE\n    //\n    function _updateDecimal(address _token) private {\n        uint256 tokenDecimals = _getTokenDecimals(_token);\n        if (decimalMap[_token] != tokenDecimals) {\n            decimalMap[_token] = tokenDecimals;\n        }\n    }\n\n    function __approve(\n        IERC20 _token,\n        address _spender,\n        Decimal.decimal memory _value\n    ) private {\n        // solhint-disable avoid-low-level-calls\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(_token.approve.selector, _spender, _toUint(_token, _value))\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"DecimalERC20: approve failed\"\n        );\n    }\n\n    // To prevent from deflationary token, check receiver's balance is as expectation.\n    function _validateBalance(\n        IERC20 _token,\n        address _to,\n        uint256 _roundedDownValue,\n        Decimal.decimal memory _balanceBefore\n    ) private view {\n        require(\n            _balanceOf(_token, _to).cmp(\n                _balanceBefore.addD(_toDecimal(_token, _roundedDownValue))\n            ) == 0,\n            \"DecimalERC20: balance inconsistent\"\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeSafe is Initializable {\n    bool private _notEntered;\n\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n\n    }\n\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/OwnerPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\nimport { PausableUpgradeSafe } from \"@openzeppelin/contracts-ethereum-package/contracts/utils/Pausable.sol\";\nimport { IfnxFiOwnableUpgrade } from \"./utils/IfnxFiOwnableUpgrade.sol\";\n\ncontract OwnerPausableUpgradeSafe is IfnxFiOwnableUpgrade, PausableUpgradeSafe {\n    // solhint-disable func-name-mixedcase\n    function __OwnerPausable_init() internal initializer {\n        __Ownable_init();\n        __Pausable_init();\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interface/IInsuranceFund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {IAmm} from \"./IAmm.sol\";\n\ninterface IInsuranceFund {\n    function withdraw(IERC20 _quoteToken, Decimal.decimal calldata _amount) external;\n\n    function isExistedAmm(IAmm _amm) external view returns (bool);\n\n    function getAllAmms() external view returns (IAmm[] memory);\n}\n"
    },
    "contracts/interface/IMultiTokenRewardRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ninterface IMultiTokenRewardRecipient {\n    function notifyTokenAmount(IERC20 _token, Decimal.decimal calldata _amount) external;\n}\n"
    },
    "@opengsn/gsn/contracts/interfaces/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.6.2;\n\n/**\n * a contract must implement this interface in order to support relayed transaction.\n * It is better to inherit the BaseRelayRecipient as its implementation.\n */\nabstract contract IRelayRecipient {\n\n    /**\n     * return if the forwarder is trusted to forward relayed transactions to us.\n     * the forwarder is required to verify the sender's signature, and verify\n     * the call is not a replay.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\n     * of the msg.data.\n     * otherwise, return `msg.sender`\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal virtual view returns (address payable);\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal virtual view returns (bytes memory);\n\n    function versionRecipient() external virtual view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract PausableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n\n\n        _paused = false;\n\n    }\n\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/RewardsDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IfnxFiOwnableUpgrade} from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport {IRewardRecipient} from \"./interface/IRewardRecipient.sol\";\nimport {Decimal} from \"./utils/Decimal.sol\";\n\nabstract contract RewardsDistributionRecipient is IfnxFiOwnableUpgrade, IRewardRecipient {\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n    address public rewardsDistribution;\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    function notifyRewardAmount(Decimal.decimal calldata _amount) external virtual override;\n\n    function setRewardsDistribution(address _rewardsDistribution) external onlyOwner {\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    modifier onlyRewardsDistribution() {\n        require(rewardsDistribution == _msgSender(), \"only rewardsDistribution\");\n        _;\n    }\n}\n"
    },
    "contracts/interface/IRewardRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRewardRecipient {\n    function notifyRewardAmount(Decimal.decimal calldata _amount) external;\n\n    function token() external returns (IERC20);\n}\n"
    },
    "contracts/RewardsDistribution.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"./utils/Decimal.sol\";\nimport {BlockContext} from \"./utils/BlockContext.sol\";\nimport {DecimalERC20} from \"./utils/DecimalERC20.sol\";\nimport {IfnxFiOwnableUpgrade} from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport {IRewardRecipient} from \"./interface/IRewardRecipient.sol\";\n\ncontract RewardsDistribution is IfnxFiOwnableUpgrade, BlockContext, DecimalERC20 {\n    using Decimal for Decimal.decimal;\n\n    //\n    // EVENTS\n    //\n    event RewardDistributed(uint256 reward, uint256 timestamp);\n\n    //\n    // STRUCT\n    //\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        Decimal.decimal amount;\n    }\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n\n    address private rewardsController;\n    IRewardRecipient private defaultRecipient;\n\n    /**\n     * @notice An array of addresses and amounts to send.\n     * this provide the flexibility for owner (DAO) to add more incentive program.\n     * eg. share 1000 Ifnx to another smart contract which will reward Ifnx/USDC Balancer LP\n     */\n    DistributionData[] public distributions;\n\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    function initialize(address _rewardsController, IRewardRecipient _defaultRecipient)\n        public\n        initializer\n    {\n        __Ownable_init();\n\n        rewardsController = _rewardsController;\n        defaultRecipient = _defaultRecipient;\n    }\n\n    function distributeRewards(IERC20 _ifnxToken, Decimal.decimal memory _amount) public {\n        require(_msgSender() == rewardsController, \"!_rewardsController\");\n\n        require(\n            _balanceOf(_ifnxToken, address(this)).toUint() >= _amount.toUint(),\n            \"not enough Ifnx\"\n        );\n\n        // Iterate the array of distributions sending the configured amounts\n        // the size of the distributions array will be controlled by owner (dao)\n        // owner should be aware of not making this array too large\n        Decimal.decimal memory remainder = _amount;\n        for (uint256 i = 0; i < distributions.length; i++) {\n            if (\n                distributions[i].destination != address(0) && distributions[i].amount.toUint() != 0\n            ) {\n                remainder = remainder.subD(distributions[i].amount);\n\n                // Transfer the Ifnx\n                _transfer(_ifnxToken, distributions[i].destination, distributions[i].amount);\n\n                bytes memory payload = abi.encodeWithSignature(\n                    \"notifyRewardAmount(uint256)\",\n                    distributions[i].amount\n                );\n\n                // solhint-disable avoid-low-level-calls\n                (bool success, ) = distributions[i].destination.call(payload);\n\n                // solhint-disable no-empty-blocks\n                if (!success) {\n                    // we're ignoring the return value as\n                    // it will fail for contracts that do not implement IRewardRecipient.sol\n                }\n            }\n        }\n\n        // staker will share all the remaining Ifnx reward\n        _transfer(_ifnxToken, address(defaultRecipient), remainder);\n        defaultRecipient.notifyRewardAmount(remainder);\n\n        emit RewardDistributed(_amount.toUint(), _blockTimestamp());\n    }\n\n    function addRewardsDistribution(address _destination, Decimal.decimal memory _amount)\n        public\n        onlyOwner\n    {\n        require(_destination != address(0), \"Cant add a zero address\");\n        require(_amount.toUint() != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(\n            address(_destination),\n            _amount\n        );\n        distributions.push(rewardsDistribution);\n    }\n\n    function removeRewardsDistribution(uint256 _index) external onlyOwner {\n        require(\n            distributions.length != 0 && _index <= distributions.length - 1,\n            \"index out of bounds\"\n        );\n\n        if (_index < distributions.length - 1) {\n            distributions[_index] = distributions[distributions.length - 1];\n        }\n        distributions.pop();\n    }\n\n    function editRewardsDistribution(\n        uint256 _index,\n        address _destination,\n        Decimal.decimal memory _amount\n    ) public onlyOwner {\n        require(\n            distributions.length != 0 && _index <= distributions.length - 1,\n            \"index out of bounds\"\n        );\n\n        distributions[_index].destination = _destination;\n        distributions[_index].amount = _amount;\n    }\n}\n"
    },
    "contracts/mock/RewardsDistributionFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../RewardsDistribution.sol\";\n\ncontract RewardsDistributionFake is RewardsDistribution {\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    function mock_getCurrentTimestamp() public view returns (uint256) {\n        return _blockTimestamp();\n    }\n\n    // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n}\n"
    },
    "contracts/mock/IfnxFiOwnableUpgradeFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/IfnxFiOwnableUpgrade.sol\";\n\ncontract IfnxFiOwnableUpgradeFake is IfnxFiOwnableUpgrade {\n    constructor() public {}\n\n    function initialize() public {\n        __Ownable_init();\n    }\n}\n"
    },
    "contracts/SupplySchedule.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IfnxFiOwnableUpgrade} from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport {Decimal, SafeMath} from \"./utils/Decimal.sol\";\nimport {BlockContext} from \"./utils/BlockContext.sol\";\nimport {IMinter} from \"./interface/IMinter.sol\";\n\ncontract SupplySchedule is IfnxFiOwnableUpgrade, BlockContext {\n    using Decimal for Decimal.decimal;\n    using SafeMath for uint256;\n\n    //\n    // CONSTANTS\n    //\n\n    // 4 years is 365 * 4 + 1 = 1,461 days\n    // 7 days * 52 weeks * 4 years = 1,456 days. if we add one more week, total days will be 1,463 days.\n    // it's over 4 years and closest to 4 years. 209 weeks = 4 * 52 + 1 weeks\n    uint256 private constant SUPPLY_DECAY_PERIOD = 209 weeks;\n\n    // Percentage growth of terminal supply per annum\n    uint256 private constant TERMINAL_SUPPLY_EPOCH_RATE = 474970697307300; // 2.5% annual ~= 0.04749% weekly\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n    Decimal.decimal public inflationRate;\n    Decimal.decimal public decayRate;\n\n    uint256 public mintDuration; // default is 1 week\n    uint256 public nextMintTime;\n    uint256 public supplyDecayEndTime; // startSchedule time + 4 years\n\n    IMinter private minter;\n\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    function initialize(\n        IMinter _minter,\n        uint256 _inflationRate,\n        uint256 _decayRate,\n        uint256 _mintDuration\n    ) public initializer {\n        __Ownable_init();\n\n        minter = _minter;\n        inflationRate = Decimal.decimal(_inflationRate);\n        mintDuration = _mintDuration;\n        decayRate = Decimal.decimal(_decayRate);\n    }\n\n    //\n    // PUBLIC FUNCTIONS\n    //\n\n    function startSchedule() external onlyOwner {\n        require(mintDuration > 0, \"mint duration is 0\");\n        nextMintTime = _blockTimestamp() + mintDuration;\n        supplyDecayEndTime = _blockTimestamp().add(SUPPLY_DECAY_PERIOD);\n    }\n\n    function setDecayRate(Decimal.decimal memory _decayRate) public onlyOwner {\n        decayRate = _decayRate;\n    }\n\n    function recordMintEvent() external {\n        require(_msgSender() == address(minter), \"!minter\");\n        //@audit - inflationRate will continue to decay even after supplyDecayEndTime, but I guess that should be fine? (@detoo)\n        inflationRate = inflationRate.mulD(Decimal.one().subD(decayRate));\n        nextMintTime = nextMintTime.add(mintDuration);\n    }\n\n    //\n    // VIEW functions\n    //\n    function mintableSupply() external view returns (Decimal.decimal memory) {\n        if (!isMintable()) {\n            return Decimal.zero();\n        }\n        uint256 totalSupply = minter.getIfnxToken().totalSupply();\n        if (_blockTimestamp() >= supplyDecayEndTime) {\n            return Decimal.decimal(totalSupply).mulD(Decimal.decimal(TERMINAL_SUPPLY_EPOCH_RATE));\n        }\n        return Decimal.decimal(totalSupply).mulD(inflationRate);\n    }\n\n    function isMintable() public view returns (bool) {\n        if (nextMintTime == 0) {\n            return false;\n        }\n        return _blockTimestamp() >= nextMintTime;\n    }\n\n    function isStarted() external view returns (bool) {\n        return nextMintTime > 0;\n    }\n}\n"
    },
    "contracts/interface/IMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ninterface IMinter {\n    function mintReward() external;\n\n    function mintForLoss(Decimal.decimal memory _amount) external;\n\n    function getIfnxToken() external view returns (IERC20);\n}\n"
    },
    "contracts/mock/SupplyScheduleFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../SupplySchedule.sol\";\n\ncontract SupplyScheduleFake is SupplySchedule {\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    function mock_getCurrentTimestamp() public view returns (uint256) {\n        return _blockTimestamp();\n    }\n\n    // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n}\n"
    },
    "contracts/StakingReserve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuardUpgradeSafe} from \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport {Decimal, SafeMath} from \"./utils/Decimal.sol\";\nimport {SignedDecimal, MixedDecimal} from \"./utils/MixedDecimal.sol\";\nimport {RewardsDistributionRecipient} from \"./RewardsDistributionRecipient.sol\";\nimport {DecimalERC20} from \"./utils/DecimalERC20.sol\";\nimport {BlockContext} from \"./utils/BlockContext.sol\";\nimport {SupplySchedule} from \"./SupplySchedule.sol\";\nimport {IMultiTokenRewardRecipient} from \"./interface/IMultiTokenRewardRecipient.sol\";\n\ncontract StakingReserve is\n    RewardsDistributionRecipient,\n    IMultiTokenRewardRecipient,\n    DecimalERC20,\n    BlockContext,\n    ReentrancyGuardUpgradeSafe\n{\n    using SafeMath for uint256;\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    //\n    // EVENTS\n    //\n    event RewardWithdrawn(address staker, uint256 amount);\n    event FeeInEpoch(address token, uint256 fee, uint256 epoch);\n\n    //\n    // STRUCT\n    //\n\n    // TODO can improve if change to cumulative version\n    struct EpochReward {\n        Decimal.decimal perpReward;\n        // key by Fee ERC20 token address\n        mapping(address => Decimal.decimal) feeMap;\n    }\n\n    struct StakeBalance {\n        bool exist;\n        // denominated in ifnxToken\n        Decimal.decimal totalBalance;\n        uint256 rewardEpochCursor;\n        uint256 feeEpochCursor;\n        // key by epochReward index (the starting epoch index when staker stake take effect)\n        mapping(uint256 => LockedBalance) lockedBalanceMap;\n    }\n\n    struct LockedBalance {\n        bool exist;\n        // locked staking amount\n        Decimal.decimal locked;\n        // timeWeightedLocked = locked * (how long has it been until endOfThisEpoch / epochPeriod)\n        Decimal.decimal timeWeightedLocked;\n    }\n\n    struct FeeBalance {\n        address token;\n        Decimal.decimal balance;\n    }\n\n    //**********************************************************//\n    //    Can not change the order of below state variables     //\n    //**********************************************************//\n    SignedDecimal.signedDecimal private totalPendingStakeBalance;\n\n    // the unit of vestingPeriod is epoch, by default 52 epochs equals to 1 year\n    uint256 public vestingPeriod;\n\n    // key by staker address\n    mapping(address => StakeBalance) public stakeBalanceMap;\n\n    // key by epoch index\n    mapping(uint256 => Decimal.decimal) private totalEffectiveStakeMap;\n\n    EpochReward[] public epochRewardHistory;\n\n    address[] public stakers;\n\n    address public ifnxToken;\n    SupplySchedule private supplySchedule;\n\n    /* @dev\n     * record all the fee tokens (not remove)\n     */\n    IERC20[] public feeTokens;\n    // key by Fee ERC20 token address\n    mapping(IERC20 => Decimal.decimal) public feeMap;\n\n    // address who can call `notifyTokenAmount`, it's `clearingHouse` for now.\n    address public feeNotifier;\n\n    IERC20 public override token;\n\n    //**********************************************************//\n    //    Can not change the order of above state variables     //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    function initialize(\n        address _ifnxToken,\n        SupplySchedule _supplySchedule,\n        address _feeNotifier,\n        uint256 _vestingPeriod\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        ifnxToken = _ifnxToken;\n        supplySchedule = _supplySchedule;\n        feeNotifier = _feeNotifier;\n        vestingPeriod = _vestingPeriod;\n    }\n\n    function setVestingPeriod(uint256 _vestingPeriod) external onlyOwner {\n        vestingPeriod = _vestingPeriod;\n    }\n\n    /**\n     * @dev staker can increase staking any time,\n     */\n    function stake(Decimal.decimal memory _amount) public {\n        require(_amount.toUint() > 0, \"Input amount is zero\");\n        address sender = _msgSender();\n        require(\n            _amount.toUint() <= getUnlockedBalance(sender).toUint(),\n            \"Stake more than all balance\"\n        );\n        require(supplySchedule.isStarted(), \"IFNX reward has not started\");\n\n        uint256 epochDuration = supplySchedule.mintDuration();\n        uint256 afterNextEpochIndex = nextEpochIndex().add(1);\n        uint256 nextEndEpochTimestamp = supplySchedule.nextMintTime();\n\n        // ignore this epoch if keeper didn't endEpoch in time\n        Decimal.decimal memory timeWeightedLocked;\n        if (nextEndEpochTimestamp > _blockTimestamp()) {\n            // calculate timeWeightedLocked based on additional staking amount and the remain time during this epoch\n            timeWeightedLocked = _amount\n                .mulScalar(nextEndEpochTimestamp.sub(_blockTimestamp()))\n                .divScalar(epochDuration);\n\n            // update stakerBalance for next epoch\n            increaseStake(sender, nextEpochIndex(), _amount, timeWeightedLocked);\n        }\n\n        // update stakerBalance for next + 1 epoch\n        StakeBalance storage balance = stakeBalanceMap[sender];\n        if (balance.lockedBalanceMap[afterNextEpochIndex].exist) {\n            increaseStake(sender, afterNextEpochIndex, _amount, _amount);\n        } else {\n            LockedBalance memory currentBalance = balance.lockedBalanceMap[nextEpochIndex()];\n            balance.lockedBalanceMap[afterNextEpochIndex] = LockedBalance(\n                true,\n                currentBalance.locked,\n                currentBalance.locked\n            );\n        }\n\n        // update global stake balance states\n        totalEffectiveStakeMap[nextEpochIndex()] = totalEffectiveStakeMap[nextEpochIndex()].addD(\n            timeWeightedLocked\n        );\n        totalPendingStakeBalance = totalPendingStakeBalance.addD(_amount).subD(timeWeightedLocked);\n    }\n\n    /**\n     * @dev staker can decrease staking from stakeBalanceForNextEpoch\n     */\n    function unstake(Decimal.decimal calldata _amount) external {\n        require(_amount.toUint() > 0, \"Input amount is zero\");\n        address sender = _msgSender();\n        require(\n            _amount.toUint() <= getUnstakableBalance(sender).toUint(),\n            \"Unstake more than locked balance\"\n        );\n\n        // decrease stake balance for after next epoch\n        uint256 afterNextEpochIndex = nextEpochIndex().add(1);\n        LockedBalance memory afterNextLockedBalance = getLockedBalance(sender, afterNextEpochIndex);\n        stakeBalanceMap[sender].lockedBalanceMap[afterNextEpochIndex] = LockedBalance(\n            true,\n            afterNextLockedBalance.locked.subD(_amount),\n            afterNextLockedBalance.timeWeightedLocked.subD(_amount)\n        );\n\n        // update global stake balance states\n        totalPendingStakeBalance = totalPendingStakeBalance.subD(_amount);\n    }\n\n    function depositAndStake(Decimal.decimal calldata _amount) external nonReentrant {\n        deposit(_msgSender(), _amount);\n        stake(_amount);\n    }\n\n    function withdraw(Decimal.decimal calldata _amount) external nonReentrant {\n        require(_amount.toUint() != 0, \"Input amount is zero\");\n        address sender = _msgSender();\n        require(_amount.toUint() <= getUnlockedBalance(sender).toUint(), \"Not enough balance\");\n        stakeBalanceMap[sender].totalBalance = stakeBalanceMap[sender].totalBalance.subD(_amount);\n        _transfer(IERC20(ifnxToken), sender, _amount);\n    }\n\n    /**\n     * @dev add epoch reward, update totalEffectiveStakeMap\n     */\n    function notifyRewardAmount(Decimal.decimal calldata _amount)\n        external\n        override\n        onlyRewardsDistribution\n    {\n        // record reward to epochRewardHistory\n        Decimal.decimal memory totalBalanceBeforeEndEpoch = getTotalBalance();\n        epochRewardHistory.push(EpochReward(_amount));\n\n        // Note this is initialized AFTER a new entry is pushed to epochRewardHistory, hence the minus 1\n        uint256 currentEpochIndex = nextEpochIndex().sub(1);\n        for (uint256 i; i < feeTokens.length; i++) {\n            IERC20 token = feeTokens[i];\n            emit FeeInEpoch(address(token), feeMap[token].toUint(), currentEpochIndex);\n            epochRewardHistory[currentEpochIndex].feeMap[address(token)] = feeMap[token];\n            feeMap[token] = Decimal.zero();\n        }\n\n        // update totalEffectiveStakeMap for coming epoch\n        SignedDecimal.signedDecimal\n            memory updatedTotalEffectiveStakeBalance = totalPendingStakeBalance.addD(\n                totalBalanceBeforeEndEpoch\n            );\n        require(updatedTotalEffectiveStakeBalance.toInt() >= 0, \"Unstake more than locked balance\");\n        totalEffectiveStakeMap[(nextEpochIndex())] = updatedTotalEffectiveStakeBalance.abs();\n        totalPendingStakeBalance = SignedDecimal.zero();\n    }\n\n    function notifyTokenAmount(IERC20 _token, Decimal.decimal calldata _amount) external override {\n        require(feeNotifier == _msgSender(), \"!feeNotifier\");\n        require(_amount.toUint() > 0, \"amount can't be 0\");\n\n        feeMap[_token] = feeMap[_token].addD(_amount);\n        if (!isExistedFeeToken(_token)) {\n            feeTokens.push(_token);\n        }\n    }\n\n    /*\n     * claim all fees and vested reward at once\n     * update lastUpdatedEffectiveStake\n     */\n    function claimFeesAndVestedReward() external nonReentrant {\n        // calculate fee and reward\n        address staker = _msgSender();\n        Decimal.decimal memory reward = getVestedReward(staker);\n        FeeBalance[] memory fees = getFeeRevenue(staker);\n        bool hasFees = fees.length > 0;\n        bool hasReward = reward.toUint() > 0;\n        require(hasReward || hasFees, \"no vested reward or fee\");\n\n        // transfer fee reward\n        stakeBalanceMap[staker].feeEpochCursor = epochRewardHistory.length;\n        for (uint256 i = 0; i < fees.length; i++) {\n            if (fees[i].balance.toUint() != 0) {\n                _transfer(IERC20(fees[i].token), staker, fees[i].balance);\n            }\n        }\n\n        // transfer perp reward\n        if (hasReward && epochRewardHistory.length >= vestingPeriod) {\n            // solhint-disable reentrancy\n            stakeBalanceMap[staker].rewardEpochCursor = epochRewardHistory.length.sub(\n                vestingPeriod\n            );\n            _transfer(IERC20(ifnxToken), staker, reward);\n            emit RewardWithdrawn(staker, reward.toUint());\n        }\n    }\n\n    function setFeeNotifier(address _notifier) external onlyOwner {\n        feeNotifier = _notifier;\n    }\n\n    //\n    // VIEW FUNCTIONS\n    //\n\n    function isExistedFeeToken(IERC20 _token) public view returns (bool) {\n        for (uint256 i = 0; i < feeTokens.length; i++) {\n            if (feeTokens[i] == _token) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function nextEpochIndex() public view returns (uint256) {\n        return epochRewardHistory.length;\n    }\n\n    /**\n     * everyone can query total balance to check current collateralization ratio.\n     * TotalBalance of time weighted locked IFNX for coming epoch\n     */\n    function getTotalBalance() public view returns (Decimal.decimal memory) {\n        return totalEffectiveStakeMap[nextEpochIndex()];\n    }\n\n    function getTotalEffectiveStake(uint256 _epochIndex)\n        public\n        view\n        returns (Decimal.decimal memory)\n    {\n        return totalEffectiveStakeMap[_epochIndex];\n    }\n\n    function getFeeOfEpoch(uint256 _epoch, address _token)\n        public\n        view\n        returns (Decimal.decimal memory)\n    {\n        return epochRewardHistory[_epoch].feeMap[_token];\n    }\n\n    function getFeeRevenue(address _staker) public view returns (FeeBalance[] memory feeBalance) {\n        StakeBalance storage balance = stakeBalanceMap[_staker];\n        if (balance.feeEpochCursor == nextEpochIndex()) {\n            return feeBalance;\n        }\n\n        uint256 numberOfTokens = feeTokens.length;\n        feeBalance = new FeeBalance[](numberOfTokens);\n        Decimal.decimal memory latestLockedStake;\n        // TODO enhancement, we can loop feeTokens first to save more gas if some feeToken was not used\n        for (uint256 i = balance.feeEpochCursor; i < nextEpochIndex(); i++) {\n            if (balance.lockedBalanceMap[i].timeWeightedLocked.toUint() != 0) {\n                latestLockedStake = balance.lockedBalanceMap[i].timeWeightedLocked;\n            }\n            if (latestLockedStake.toUint() == 0) {\n                continue;\n            }\n            Decimal.decimal memory effectiveStakePercentage = latestLockedStake.divD(\n                totalEffectiveStakeMap[i]\n            );\n\n            for (uint256 j = 0; j < numberOfTokens; j++) {\n                IERC20 token = feeTokens[j];\n                Decimal.decimal memory feeInThisEpoch = getFeeOfEpoch(i, address(token));\n                if (feeInThisEpoch.toUint() == 0) {\n                    continue;\n                }\n                feeBalance[j].balance = feeBalance[j].balance.addD(\n                    feeInThisEpoch.mulD(effectiveStakePercentage)\n                );\n                feeBalance[j].token = address(token);\n            }\n        }\n    }\n\n    function getVestedReward(address _staker) public view returns (Decimal.decimal memory reward) {\n        if (nextEpochIndex() < vestingPeriod) {\n            return Decimal.zero();\n        }\n\n        // Note that rewardableEpochEnd is exclusive. The last rewardable epoch index = rewardableEpochEnd - 1\n        uint256 rewardableEpochEnd = nextEpochIndex().sub(vestingPeriod);\n        StakeBalance storage balance = stakeBalanceMap[_staker];\n        if (balance.rewardEpochCursor > rewardableEpochEnd) {\n            return Decimal.zero();\n        }\n\n        Decimal.decimal memory latestLockedStake;\n        for (uint256 i = balance.rewardEpochCursor; i < rewardableEpochEnd; i++) {\n            if (balance.lockedBalanceMap[i].timeWeightedLocked.toUint() != 0) {\n                latestLockedStake = balance.lockedBalanceMap[i].timeWeightedLocked;\n            }\n            if (latestLockedStake.toUint() == 0) {\n                continue;\n            }\n            Decimal.decimal memory rewardInThisEpoch = epochRewardHistory[i]\n                .perpReward\n                .mulD(latestLockedStake)\n                .divD(totalEffectiveStakeMap[i]);\n            reward = reward.addD(rewardInThisEpoch);\n        }\n    }\n\n    function getUnlockedBalance(address _staker) public view returns (Decimal.decimal memory) {\n        Decimal.decimal memory lockedForNextEpoch = getLockedBalance(_staker, nextEpochIndex())\n            .locked;\n        return stakeBalanceMap[_staker].totalBalance.subD(lockedForNextEpoch);\n    }\n\n    // unstakable = lockedBalance@NextEpoch+1\n    function getUnstakableBalance(address _staker) public view returns (Decimal.decimal memory) {\n        return getLockedBalance(_staker, nextEpochIndex().add(1)).locked;\n    }\n\n    // only store locked balance when there's changed, so if the target lockedBalance is not exist,\n    // use the lockedBalance from the closest previous epoch\n    function getLockedBalance(address _staker, uint256 _epochIndex)\n        public\n        view\n        returns (LockedBalance memory)\n    {\n        while (_epochIndex >= 0) {\n            LockedBalance memory lockedBalance = stakeBalanceMap[_staker].lockedBalanceMap[\n                _epochIndex\n            ];\n            if (lockedBalance.exist) {\n                return lockedBalance;\n            }\n            if (_epochIndex == 0) {\n                break;\n            }\n            _epochIndex -= 1;\n        }\n        return LockedBalance(false, Decimal.zero(), Decimal.zero());\n    }\n\n    function getEpochRewardHistoryLength() external view returns (uint256) {\n        return epochRewardHistory.length;\n    }\n\n    function getRewardEpochCursor(address _staker) public view returns (uint256) {\n        return stakeBalanceMap[_staker].rewardEpochCursor;\n    }\n\n    function getFeeEpochCursor(address _staker) public view returns (uint256) {\n        return stakeBalanceMap[_staker].feeEpochCursor;\n    }\n\n    //\n    // Private\n    //\n\n    function increaseStake(\n        address _sender,\n        uint256 _epochIndex,\n        Decimal.decimal memory _locked,\n        Decimal.decimal memory _timeWeightedLocked\n    ) private {\n        LockedBalance memory lockedBalance = getLockedBalance(_sender, _epochIndex);\n        stakeBalanceMap[_sender].lockedBalanceMap[_epochIndex] = LockedBalance(\n            true,\n            lockedBalance.locked.addD(_locked),\n            lockedBalance.timeWeightedLocked.addD(_timeWeightedLocked)\n        );\n    }\n\n    function deposit(address _sender, Decimal.decimal memory _amount) private {\n        require(_amount.toUint() != 0, \"Input amount is zero\");\n        StakeBalance storage balance = stakeBalanceMap[_sender];\n        if (!balance.exist) {\n            stakers.push(_sender);\n            balance.exist = true;\n            // set rewardEpochCursor for the first staking\n            balance.rewardEpochCursor = nextEpochIndex();\n        }\n        balance.totalBalance = balance.totalBalance.addD(_amount);\n        _transferFrom(IERC20(ifnxToken), _sender, address(this), _amount);\n    }\n}\n"
    },
    "contracts/mock/ERC20MinimalFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ContextUpgradeSafe} from \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\nimport {Address} from \"@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n// TODO rename to ERC20NoDecimal\ncontract ERC20MinimalFake is Initializable, ContextUpgradeSafe, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    function initializeERC20MinimalFake(uint256 initialSupply) public initializer {\n        __Context_init_unchained();\n        _mint(_msgSender(), initialSupply);\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        require(_allowances[owner][spender] == 0 || amount == 0, \"ERC20: approve non zero amount\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20UpgradeSafe is Initializable, ContextUpgradeSafe, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n    }\n\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\n\n\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n\n    }\n\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeSafe is Initializable, ERC20UpgradeSafe, PausableUpgradeSafe {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n\n\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeSafe is Initializable, ContextUpgradeSafe, ERC20UpgradeSafe {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n\n\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, _msgSender()));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n */\nabstract contract AccessControlUpgradeSafe is Initializable, ContextUpgradeSafe {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n\n\n    }\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/presets/ERC20PresetMinterPauser.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../token/ERC20/ERC20.sol\";\nimport \"../token/ERC20/ERC20Burnable.sol\";\nimport \"../token/ERC20/ERC20Pausable.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to aother accounts\n */\ncontract ERC20PresetMinterPauserUpgradeSafe is Initializable, ContextUpgradeSafe, AccessControlUpgradeSafe, ERC20BurnableUpgradeSafe, ERC20PausableUpgradeSafe {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n\n    function initialize(string memory name, string memory symbol) public {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __ERC20Burnable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {\n\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n\n    }\n\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(ERC20UpgradeSafe, ERC20PausableUpgradeSafe) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/mock/ERC20Fake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ERC20PresetMinterPauserUpgradeSafe} from \"@openzeppelin/contracts-ethereum-package/contracts/presets/ERC20PresetMinterPauser.sol\";\n\n// TODO rename to UpgradableMintableERC20\ncontract ERC20Fake is ERC20PresetMinterPauserUpgradeSafe {\n    function initializeERC20Fake(\n        uint256 initialSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimal\n    ) public initializer {\n        ERC20PresetMinterPauserUpgradeSafe.initialize(name, symbol);\n        _setupDecimals(decimal);\n        _mint(_msgSender(), initialSupply);\n    }\n}\n"
    },
    "contracts/interface/IClearingHouse.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-CLAUSE\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {SignedDecimal} from \"../utils/SignedDecimal.sol\";\nimport {IAmm} from \"./IAmm.sol\";\n\ninterface IClearingHouse {\n    enum Side {\n        BUY,\n        SELL\n    }\n\n    /// @notice This struct records personal position information\n    /// @param size denominated in amm.baseAsset\n    /// @param margin isolated margin\n    /// @param openNotional the quoteAsset value of position when opening position. the cost of the position\n    /// @param lastUpdatedCumulativePremiumFraction for calculating funding payment, record at the moment every time when trader open/reduce/close position\n    /// @param liquidityHistoryIndex\n    /// @param blockNumber the block number of the last position\n    struct Position {\n        SignedDecimal.signedDecimal size;\n        Decimal.decimal margin;\n        Decimal.decimal openNotional;\n        SignedDecimal.signedDecimal lastUpdatedCumulativePremiumFraction;\n        uint256 liquidityHistoryIndex;\n        uint256 blockNumber;\n    }\n\n    function addMargin(IAmm _amm, Decimal.decimal calldata _addedMargin) external;\n\n    function removeMargin(IAmm _amm, Decimal.decimal calldata _removedMargin) external;\n\n    function settlePosition(IAmm _amm) external;\n\n    function openPosition(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _leverage,\n        Decimal.decimal calldata _baseAssetAmountLimit\n    ) external;\n\n    function closePosition(IAmm _amm, Decimal.decimal calldata _quoteAssetAmountLimit) external;\n\n    function liquidate(IAmm _amm, address _trader) external;\n\n    function payFunding(IAmm _amm) external;\n\n    // VIEW FUNCTIONS\n    function getMarginRatio(IAmm _amm, address _trader)\n        external\n        view\n        returns (SignedDecimal.signedDecimal memory);\n\n    function getPosition(IAmm _amm, address _trader) external view returns (Position memory);\n}\n"
    },
    "contracts/mock/SignedDecimalFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/SignedDecimal.sol\";\n\ncontract SignedDecimalFake {\n    using SignedDecimal for SignedDecimal.signedDecimal;\n\n    constructor() public {}\n\n    /// @dev multiple two decimals\n    function mul(SignedDecimal.signedDecimal memory x, SignedDecimal.signedDecimal memory y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.mulD(y);\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by a int256\n    function mulScalar(SignedDecimal.signedDecimal memory x, int256 y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.mulScalar(y);\n    }\n\n    /// @dev divide two decimals\n    function div(SignedDecimal.signedDecimal memory x, SignedDecimal.signedDecimal memory y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.divD(y);\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a int256\n    function divScalar(SignedDecimal.signedDecimal memory x, int256 y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.divScalar(y);\n    }\n}\n"
    },
    "contracts/mock/mocks/AmmMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/SignedDecimal.sol\";\nimport \"../../Amm.sol\";\n\ncontract AmmMock {\n    using SafeMath for uint256;\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    event Dir(Amm.Dir dir);\n\n    IERC20 public quoteAsset;\n    Decimal.decimal public quoteAssetReserve;\n    Decimal.decimal public baseAssetReserve;\n\n    /*\n     * For removeMargin mocks\n     */\n    Decimal.decimal private outputTwap;\n    Decimal.decimal private outputPrice;\n    Decimal.decimal private inputPrice;\n\n    constructor() public {}\n\n    /*\n     * For payFundingRate mocks\n     */\n    SignedDecimal.signedDecimal private _fundingRate;\n\n    function mockSetFundingRate(SignedDecimal.signedDecimal memory _fr) public {\n        _fundingRate = _fr;\n    }\n\n    function mockSetQuoteAsset(IERC20 _quoteAsset) public {\n        quoteAsset = _quoteAsset;\n    }\n\n    function fundingRate() public view returns (SignedDecimal.signedDecimal memory) {\n        return _fundingRate;\n    }\n\n    function settleFunding() public {}\n\n    function mockSetOutputTwap(Decimal.decimal memory _outputTwap) public {\n        outputTwap = _outputTwap;\n    }\n\n    function mockSetOutputPrice(Decimal.decimal memory _outputPrice) public {\n        outputPrice = _outputPrice;\n    }\n\n    function mockSetInputPrice(Decimal.decimal memory _inputPrice) public {\n        inputPrice = _inputPrice;\n    }\n\n    function getOutputTwap(Amm.Dir, Decimal.decimal calldata) external view returns (Decimal.decimal memory) {\n        return outputTwap;\n    }\n\n    function getOutputPrice(Amm.Dir, Decimal.decimal calldata) external view returns (Decimal.decimal memory) {\n        return outputPrice;\n    }\n\n    function getInputPrice(Amm.Dir, Decimal.decimal calldata) external view returns (Decimal.decimal memory) {\n        return inputPrice;\n    }\n\n    function getReserve() external view returns (Decimal.decimal memory, Decimal.decimal memory) {\n        return (quoteAssetReserve, baseAssetReserve);\n    }\n\n    function swapInput(\n        Amm.Dir,\n        Decimal.decimal calldata,\n        Decimal.decimal calldata\n    ) external returns (Decimal.decimal memory) {\n        return inputPrice;\n    }\n\n    function swapOutput(Amm.Dir, Decimal.decimal calldata) external returns (Decimal.decimal memory) {\n        return outputPrice;\n    }\n\n    function mockSetBaseAssetReserve(Decimal.decimal memory _baseAssetReserve) public {\n        baseAssetReserve = _baseAssetReserve;\n    }\n\n    function mockSetQuoteAssetReserve(Decimal.decimal memory _quoteAssetReserve) public {\n        quoteAssetReserve = _quoteAssetReserve;\n    }\n}"
    },
    "contracts/ClearingHouseViewer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport { Decimal } from \"./utils/Decimal.sol\";\nimport { SignedDecimal } from \"./utils/SignedDecimal.sol\";\nimport { MixedDecimal } from \"./utils/MixedDecimal.sol\";\nimport { IAmm } from \"./interface/IAmm.sol\";\nimport { IInsuranceFund } from \"./interface/IInsuranceFund.sol\";\nimport { ClearingHouse } from \"./ClearingHouse.sol\";\n\ncontract ClearingHouseViewer {\n    using SafeMath for uint256;\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    ClearingHouse public clearingHouse;\n\n    //\n    // FUNCTIONS\n    //\n\n    constructor(ClearingHouse _clearingHouse) public {\n        clearingHouse = _clearingHouse;\n    }\n\n    //\n    // Public\n    //\n\n    /**\n     * @notice get unrealized PnL\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @param _pnlCalcOption ClearingHouse.PnlCalcOption, can be SPOT_PRICE or TWAP.\n     * @return unrealized PnL in 18 digits\n     */\n    function getUnrealizedPnl(\n        IAmm _amm,\n        address _trader,\n        ClearingHouse.PnlCalcOption _pnlCalcOption\n    ) external view returns (SignedDecimal.signedDecimal memory) {\n        (, SignedDecimal.signedDecimal memory unrealizedPnl) =\n            (clearingHouse.getPositionNotionalAndUnrealizedPnl(_amm, _trader, _pnlCalcOption));\n        return unrealizedPnl;\n    }\n\n    /**\n     * @notice get personal balance with funding payment\n     * @param _quoteToken ERC20 token address\n     * @param _trader trader address\n     * @return margin personal balance with funding payment in 18 digits\n     */\n    function getPersonalBalanceWithFundingPayment(IERC20 _quoteToken, address _trader)\n        external\n        view\n        returns (Decimal.decimal memory margin)\n    {\n        IInsuranceFund insuranceFund = clearingHouse.insuranceFund();\n        IAmm[] memory amms = insuranceFund.getAllAmms();\n        for (uint256 i = 0; i < amms.length; i++) {\n            if (IAmm(amms[i]).quoteAsset() != _quoteToken) {\n                continue;\n            }\n            Decimal.decimal memory posMargin = getPersonalPositionWithFundingPayment(amms[i], _trader).margin;\n            margin = margin.addD(posMargin);\n        }\n    }\n\n    /**\n     * @notice get personal position with funding payment\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return position ClearingHouse.Position struct\n     */\n    function getPersonalPositionWithFundingPayment(IAmm _amm, address _trader)\n        public\n        view\n        returns (ClearingHouse.Position memory position)\n    {\n        position = clearingHouse.getPosition(_amm, _trader);\n        SignedDecimal.signedDecimal memory marginWithFundingPayment =\n            MixedDecimal.fromDecimal(position.margin).addD(\n                getFundingPayment(position, clearingHouse.getLatestCumulativePremiumFraction(_amm))\n            );\n        position.margin = marginWithFundingPayment.toInt() >= 0 ? marginWithFundingPayment.abs() : Decimal.zero();\n    }\n\n    /**\n     * @notice verify if trader's position needs to be migrated\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return true if trader's position is not at the latest Amm curve, otherwise is false\n     */\n    function isPositionNeedToBeMigrated(IAmm _amm, address _trader) external view returns (bool) {\n        ClearingHouse.Position memory unadjustedPosition = clearingHouse.getUnadjustedPosition(_amm, _trader);\n        if (unadjustedPosition.size.toInt() == 0) {\n            return false;\n        }\n        uint256 latestLiquidityIndex = _amm.getLiquidityHistoryLength().sub(1);\n        if (unadjustedPosition.liquidityHistoryIndex == latestLiquidityIndex) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @notice get personal margin ratio\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return personal margin ratio in 18 digits\n     */\n    function getMarginRatio(IAmm _amm, address _trader) external view returns (SignedDecimal.signedDecimal memory) {\n        return clearingHouse.getMarginRatio(_amm, _trader);\n    }\n\n    /**\n     * @notice get withdrawable margin\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return withdrawable margin in 18 digits\n     */\n    function getFreeCollateral(IAmm _amm, address _trader) external view returns (SignedDecimal.signedDecimal memory) {\n        // get trader's margin\n        ClearingHouse.Position memory position = getPersonalPositionWithFundingPayment(_amm, _trader);\n\n        // get trader's unrealized PnL and choose the least beneficial one for the trader\n        (Decimal.decimal memory spotPositionNotional, SignedDecimal.signedDecimal memory spotPricePnl) =\n            (clearingHouse.getPositionNotionalAndUnrealizedPnl(_amm, _trader, ClearingHouse.PnlCalcOption.SPOT_PRICE));\n        (Decimal.decimal memory twapPositionNotional, SignedDecimal.signedDecimal memory twapPricePnl) =\n            (clearingHouse.getPositionNotionalAndUnrealizedPnl(_amm, _trader, ClearingHouse.PnlCalcOption.TWAP));\n\n        SignedDecimal.signedDecimal memory unrealizedPnl;\n        Decimal.decimal memory positionNotional;\n        (unrealizedPnl, positionNotional) = (spotPricePnl.toInt() > twapPricePnl.toInt())\n            ? (twapPricePnl, twapPositionNotional)\n            : (spotPricePnl, spotPositionNotional);\n\n        // min(margin + funding, margin + funding + unrealized PnL) - position value * initMarginRatio\n        SignedDecimal.signedDecimal memory accountValue = unrealizedPnl.addD(position.margin);\n        SignedDecimal.signedDecimal memory minCollateral =\n            accountValue.subD(position.margin).toInt() > 0 ? MixedDecimal.fromDecimal(position.margin) : accountValue;\n\n        Decimal.decimal memory initMarginRatio = Decimal.decimal(clearingHouse.initMarginRatio());\n        SignedDecimal.signedDecimal memory marginRequirement =\n            position.size.toInt() > 0\n                ? MixedDecimal.fromDecimal(position.openNotional).mulD(initMarginRatio)\n                : MixedDecimal.fromDecimal(positionNotional).mulD(initMarginRatio);\n\n        return minCollateral.subD(marginRequirement);\n    }\n\n    //\n    // PRIVATE\n    //\n\n    // negative means trader paid and vice versa\n    function getFundingPayment(\n        ClearingHouse.Position memory _position,\n        SignedDecimal.signedDecimal memory _latestCumulativePremiumFraction\n    ) private pure returns (SignedDecimal.signedDecimal memory) {\n        return\n            _position.size.toInt() == 0\n                ? SignedDecimal.zero()\n                : _latestCumulativePremiumFraction\n                    .subD(_position.lastUpdatedCumulativePremiumFraction)\n                    .mulD(_position.size)\n                    .mulScalar(-1);\n    }\n}\n"
    },
    "contracts/InsuranceFund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { IfnxFiOwnableUpgrade } from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport {\n    ReentrancyGuardUpgradeSafe\n} from \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport { Decimal } from \"./utils/Decimal.sol\";\nimport { IExchangeWrapper } from \"./interface/IExchangeWrapper.sol\";\nimport { IInsuranceFund } from \"./interface/IInsuranceFund.sol\";\nimport { BlockContext } from \"./utils/BlockContext.sol\";\nimport { DecimalERC20 } from \"./utils/DecimalERC20.sol\";\nimport { IMinter } from \"./interface/IMinter.sol\";\nimport { IAmm } from \"./interface/IAmm.sol\";\nimport { IInflationMonitor } from \"./interface/IInflationMonitor.sol\";\n\ncontract InsuranceFund is IInsuranceFund, IfnxFiOwnableUpgrade, BlockContext, ReentrancyGuardUpgradeSafe, DecimalERC20 {\n    using Decimal for Decimal.decimal;\n\n    //\n    // EVENTS\n    //\n\n    event Withdrawn(address withdrawer, uint256 amount);\n    event TokenAdded(address tokenAddress);\n    event TokenRemoved(address tokenAddress);\n    event ShutdownAllAmms(uint256 blockNumber);\n    event AmmAdded(address amm);\n    event AmmRemoved(address amm);\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n\n    mapping(address => bool) private ammMap;\n    mapping(address => bool) private quoteTokenMap;\n    IAmm[] private amms;\n    IERC20[] public quoteTokens;\n\n    // contract dependencies\n    IExchangeWrapper public exchange;\n    IERC20 public ifnxToken;\n    IMinter public minter;\n    IInflationMonitor public inflationMonitor;\n    address private beneficiary;\n\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    function initialize() external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @dev only owner can call\n     * @param _amm IAmm address\n     */\n    function addAmm(IAmm _amm) public onlyOwner {\n        require(!isExistedAmm(_amm), \"amm already added\");\n        ammMap[address(_amm)] = true;\n        amms.push(_amm);\n        emit AmmAdded(address(_amm));\n\n        // add token if it's new one\n        IERC20 token = _amm.quoteAsset();\n        if (!isQuoteTokenExisted(token)) {\n            quoteTokens.push(token);\n            quoteTokenMap[address(token)] = true;\n            emit TokenAdded(address(token));\n        }\n    }\n\n    /**\n     * @dev only owner can call. no need to call\n     * @param _amm IAmm address\n     */\n    function removeAmm(IAmm _amm) external onlyOwner {\n        require(isExistedAmm(_amm), \"amm not existed\");\n        ammMap[address(_amm)] = false;\n        uint256 ammLength = amms.length;\n        for (uint256 i = 0; i < ammLength; i++) {\n            if (amms[i] == _amm) {\n                amms[i] = amms[ammLength - 1];\n                amms.pop();\n                emit AmmRemoved(address(_amm));\n                break;\n            }\n        }\n    }\n\n    /**\n     * @notice shutdown all Amms when fatal error happens\n     * @dev only owner can call. Emit `ShutdownAllAmms` event\n     */\n    function shutdownAllAmm() external onlyOwner {\n        if (!inflationMonitor.isOverMintThreshold()) {\n            return;\n        }\n        for (uint256 i; i < amms.length; i++) {\n            amms[i].shutdown();\n        }\n        emit ShutdownAllAmms(block.number);\n    }\n\n    function removeToken(IERC20 _token) external onlyOwner {\n        require(isQuoteTokenExisted(_token), \"token not existed\");\n\n        quoteTokenMap[address(_token)] = false;\n        uint256 quoteTokensLength = getQuoteTokenLength();\n        for (uint256 i = 0; i < quoteTokensLength; i++) {\n            if (quoteTokens[i] == _token) {\n                if (i < quoteTokensLength - 1) {\n                    quoteTokens[i] = quoteTokens[quoteTokensLength - 1];\n                }\n                quoteTokens.pop();\n                break;\n            }\n        }\n\n        // exchange and transfer to the quoteToken with the most value. if no more quoteToken, buy protocol tokens\n        // TODO use curve or balancer fund token for pooling the fees will be less painful\n        if (balanceOf(_token).toUint() > 0) {\n            address outputToken = getTokenWithMaxValue();\n            if (outputToken == address(0)) {\n                outputToken = address(ifnxToken);\n            }\n            swapInput(_token, IERC20(outputToken), balanceOf(_token), Decimal.zero());\n        }\n\n        emit TokenRemoved(address(_token));\n    }\n\n    /**\n     * @notice withdraw token to caller\n     * @param _amount the amount of quoteToken caller want to withdraw\n     */\n    function withdraw(IERC20 _quoteToken, Decimal.decimal calldata _amount) external override {\n        require(beneficiary == _msgSender(), \"caller is not beneficiary\");\n        require(isQuoteTokenExisted(_quoteToken), \"Asset is not supported\");\n\n        Decimal.decimal memory quoteBalance = balanceOf(_quoteToken);\n        if (_amount.toUint() > quoteBalance.toUint()) {\n            Decimal.decimal memory insufficientAmount = _amount.subD(quoteBalance);\n            swapEnoughQuoteAmount(_quoteToken, insufficientAmount);\n            quoteBalance = balanceOf(_quoteToken);\n        }\n        require(quoteBalance.toUint() >= _amount.toUint(), \"Fund not enough\");\n\n        _transfer(_quoteToken, _msgSender(), _amount);\n        emit Withdrawn(_msgSender(), _amount.toUint());\n    }\n\n    //\n    // SETTER\n    //\n\n    function setExchange(IExchangeWrapper _exchange) external onlyOwner {\n        exchange = _exchange;\n    }\n\n    function setBeneficiary(address _beneficiary) external onlyOwner {\n        beneficiary = _beneficiary;\n    }\n\n    function setMinter(IMinter _minter) public onlyOwner {\n        minter = _minter;\n        ifnxToken = minter.getIfnxToken();\n    }\n\n    function setInflationMonitor(IInflationMonitor _inflationMonitor) external onlyOwner {\n        inflationMonitor = _inflationMonitor;\n    }\n\n    function getQuoteTokenLength() public view returns (uint256) {\n        return quoteTokens.length;\n    }\n\n    //\n    // INTERNAL FUNCTIONS\n    //\n\n    function getTokenWithMaxValue() internal view returns (address) {\n        uint256 numOfQuoteTokens = quoteTokens.length;\n        if (numOfQuoteTokens == 0) {\n            return address(0);\n        }\n        if (numOfQuoteTokens == 1) {\n            return address(quoteTokens[0]);\n        }\n\n        IERC20 denominatedToken = quoteTokens[0];\n        IERC20 maxValueToken = denominatedToken;\n        Decimal.decimal memory valueOfMaxValueToken = balanceOf(denominatedToken);\n        for (uint256 i = 1; i < numOfQuoteTokens; i++) {\n            IERC20 quoteToken = quoteTokens[i];\n            Decimal.decimal memory quoteTokenValue =\n                exchange.getInputPrice(quoteToken, denominatedToken, balanceOf(quoteToken));\n            if (quoteTokenValue.cmp(valueOfMaxValueToken) > 0) {\n                maxValueToken = quoteToken;\n                valueOfMaxValueToken = quoteTokenValue;\n            }\n        }\n        return address(maxValueToken);\n    }\n\n    function swapInput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal memory inputTokenSold,\n        Decimal.decimal memory minOutputTokenBought\n    ) internal returns (Decimal.decimal memory received) {\n        if (inputTokenSold.toUint() == 0) {\n            return Decimal.zero();\n        }\n        _approve(inputToken, address(exchange), inputTokenSold);\n        received = exchange.swapInput(inputToken, outputToken, inputTokenSold, minOutputTokenBought, Decimal.zero());\n        require(received.toUint() > 0, \"Exchange swap error\");\n    }\n\n    function swapOutput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal memory outputTokenBought,\n        Decimal.decimal memory maxInputTokenSold\n    ) internal returns (Decimal.decimal memory received) {\n        if (outputTokenBought.toUint() == 0) {\n            return Decimal.zero();\n        }\n        _approve(inputToken, address(exchange), maxInputTokenSold);\n        received = exchange.swapOutput(inputToken, outputToken, outputTokenBought, maxInputTokenSold, Decimal.zero());\n        require(received.toUint() > 0, \"Exchange swap error\");\n    }\n\n    function swapEnoughQuoteAmount(IERC20 _quoteToken, Decimal.decimal memory _requiredQuoteAmount) internal {\n        IERC20[] memory orderedTokens = getOrderedQuoteTokens(_quoteToken);\n        for (uint256 i = 0; i < orderedTokens.length; i++) {\n            // get how many amount of quote token i is still required\n            Decimal.decimal memory swappedQuoteToken;\n            Decimal.decimal memory otherQuoteRequiredAmount =\n                exchange.getOutputPrice(orderedTokens[i], _quoteToken, _requiredQuoteAmount);\n\n            // if balance of token i can afford the left debt, swap and return\n            if (otherQuoteRequiredAmount.toUint() <= balanceOf(orderedTokens[i]).toUint()) {\n                swappedQuoteToken = swapInput(orderedTokens[i], _quoteToken, otherQuoteRequiredAmount, Decimal.zero());\n                return;\n            }\n\n            // if balance of token i can't afford the left debt, show hand and move to the next one\n            swappedQuoteToken = swapInput(orderedTokens[i], _quoteToken, balanceOf(orderedTokens[i]), Decimal.zero());\n            _requiredQuoteAmount = _requiredQuoteAmount.subD(swappedQuoteToken);\n        }\n\n        // if all the quote tokens can't afford the debt, ask staking token to mint\n        if (_requiredQuoteAmount.toUint() > 0) {\n            Decimal.decimal memory requiredIfnxAmount =\n                exchange.getOutputPrice(ifnxToken, _quoteToken, _requiredQuoteAmount);\n            minter.mintForLoss(requiredIfnxAmount);\n            swapInput(ifnxToken, _quoteToken, requiredIfnxAmount, Decimal.zero());\n        }\n    }\n\n    //\n    // VIEW\n    //\n    function isExistedAmm(IAmm _amm) public view override returns (bool) {\n        return ammMap[address(_amm)];\n    }\n\n    function getAllAmms() external view override returns (IAmm[] memory) {\n        return amms;\n    }\n\n    function isQuoteTokenExisted(IERC20 _token) internal view returns (bool) {\n        return quoteTokenMap[address(_token)];\n    }\n\n    function getOrderedQuoteTokens(IERC20 _exceptionQuoteToken) internal view returns (IERC20[] memory orderedTokens) {\n        IERC20[] memory tokens = quoteTokens;\n        // insertion sort\n        for (uint256 i = 0; i < getQuoteTokenLength(); i++) {\n            IERC20 currentToken = quoteTokens[i];\n            Decimal.decimal memory currentIfnxValue =\n                exchange.getInputPrice(currentToken, ifnxToken, balanceOf(currentToken));\n\n            for (uint256 j = i; j > 0; j--) {\n                Decimal.decimal memory subsetIfnxValue =\n                    exchange.getInputPrice(tokens[j - 1], ifnxToken, balanceOf(tokens[j - 1]));\n                if (currentIfnxValue.toUint() > subsetIfnxValue.toUint()) {\n                    tokens[j] = tokens[j - 1];\n                    tokens[j - 1] = currentToken;\n                }\n            }\n        }\n\n        orderedTokens = new IERC20[](tokens.length - 1);\n        uint256 j;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            // jump to the next token\n            if (tokens[i] == _exceptionQuoteToken) {\n                continue;\n            }\n            orderedTokens[j] = tokens[i];\n            j++;\n        }\n    }\n\n    function balanceOf(IERC20 _quoteToken) internal view returns (Decimal.decimal memory) {\n        return _balanceOf(_quoteToken, address(this));\n    }\n}\n"
    },
    "contracts/interface/IExchangeWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExchangeWrapper {\n    function swapInput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata inputTokenSold,\n        Decimal.decimal calldata minOutputTokenBought,\n        Decimal.decimal calldata maxPrice\n    ) external returns (Decimal.decimal memory);\n\n    function swapOutput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata outputTokenBought,\n        Decimal.decimal calldata maxInputTokeSold,\n        Decimal.decimal calldata maxPrice\n    ) external returns (Decimal.decimal memory);\n\n    function getInputPrice(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata inputTokenSold\n    ) external view returns (Decimal.decimal memory);\n\n    function getOutputPrice(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata outputTokenBought\n    ) external view returns (Decimal.decimal memory);\n\n    function getSpotPrice(IERC20 inputToken, IERC20 outputToken)\n        external\n        view\n        returns (Decimal.decimal memory);\n}\n"
    },
    "contracts/interface/IInflationMonitor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ninterface IInflationMonitor {\n    function isOverMintThreshold() external view returns (bool);\n\n    function appendMintedTokenHistory(Decimal.decimal calldata _amount) external;\n}\n"
    },
    "contracts/mock/InsuranceFundFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../InsuranceFund.sol\";\n\ncontract InsuranceFundFake is InsuranceFund {\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    // make internal function testable\n    function testGetOrderedQuoteTokens(IERC20 _exceptionQuoteToken)\n        external\n        view\n        returns (IERC20[] memory orderedTokens)\n    {\n        return getOrderedQuoteTokens(_exceptionQuoteToken);\n    }\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    function mock_getCurrentTimestamp() public view returns (uint256) {\n        return _blockTimestamp();\n    }\n\n    // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n}\n"
    },
    "contracts/Minter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport { IfnxFiOwnableUpgrade } from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport { Decimal } from \"./utils/Decimal.sol\";\nimport { SupplySchedule } from \"./SupplySchedule.sol\";\nimport { RewardsDistribution } from \"./RewardsDistribution.sol\";\nimport { IInflationMonitor } from \"./interface/IInflationMonitor.sol\";\nimport { IIfnxToken } from \"./interface/IIfnxToken.sol\";\nimport { IMinter } from \"./interface/IMinter.sol\";\n\ncontract Minter is IMinter, IfnxFiOwnableUpgrade {\n    using Decimal for Decimal.decimal;\n\n    //\n    // EVENT\n    //\n    event IfnxMinted(uint256 amount);\n\n    //**********************************************************//\n    //    Can not change the order of below state variables     //\n    //**********************************************************//\n\n    address private ifnxToken;\n    SupplySchedule public supplySchedule;\n    RewardsDistribution public rewardsDistribution;\n    IInflationMonitor public inflationMonitor;\n    address public insuranceFund;\n\n    //**********************************************************//\n    //    Can not change the order of above state variables     //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    /**\n     * @notice pre-minted tokens will transfer to the contract creator\n     * (contract creator will be admin, minter and pauser),\n     * but mint() will transfer to the minter (because only minter can mint)\n     * @notice openzeppelin doesn't support struct input\n     * https://github.com/OpenZeppelin/openzeppelin-sdk/issues/1523\n     */\n    function initialize(address _ifnxToken) public initializer {\n        __Ownable_init();\n\n        ifnxToken = _ifnxToken;\n    }\n\n    //*************** ERC20 functions ***************//\n    //\n    // PUBLIC functions\n    //\n\n    // mintReward is open to everyone (keeper) as long as it meets the condition\n    function mintReward() external override {\n        uint256 mintableSupply = supplySchedule.mintableSupply().toUint();\n        require(mintableSupply > 0, \"no supply is mintable\");\n\n        IIfnxToken(ifnxToken).mint(address(rewardsDistribution), mintableSupply);\n        rewardsDistribution.distributeRewards(IERC20(ifnxToken), Decimal.decimal(mintableSupply));\n\n        // record minting event before mutation to token supply\n        supplySchedule.recordMintEvent();\n\n        emit IfnxMinted(mintableSupply);\n    }\n\n    // mint for covering unexpected loss, only insurance fund\n    function mintForLoss(Decimal.decimal memory _amount) public override {\n        require(insuranceFund == _msgSender(), \"only insuranceFund\");\n        require(address(inflationMonitor) != address(0), \"inflationMonitor not fount\");\n\n        // minter role checking is inside `mint`\n        // mint to insuranceFund\n        IIfnxToken(ifnxToken).mint(insuranceFund, _amount.toUint());\n        inflationMonitor.appendMintedTokenHistory(_amount);\n\n        emit IfnxMinted(_amount.toUint());\n    }\n\n    function setInsuranceFund(address _insuranceFund) external onlyOwner {\n        insuranceFund = _insuranceFund;\n    }\n\n    function setRewardsDistribution(RewardsDistribution _rewardsDistribution) external onlyOwner {\n        rewardsDistribution = _rewardsDistribution;\n    }\n\n    function setSupplySchedule(SupplySchedule _supplySchedule) external onlyOwner {\n        supplySchedule = _supplySchedule;\n    }\n\n    function setInflationMonitor(IInflationMonitor _inflationMonitor) external onlyOwner {\n        inflationMonitor = _inflationMonitor;\n    }\n\n    function getIfnxToken() external view override returns (IERC20) {\n        return IERC20(ifnxToken);\n    }\n}\n"
    },
    "contracts/interface/IIfnxToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\n\ninterface IIfnxToken {\n    function mint(address account, uint256 amount) external;\n}\n"
    },
    "contracts/InflationMonitor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IfnxFiOwnableUpgrade} from \"./utils/IfnxFiOwnableUpgrade.sol\";\nimport {Decimal, SafeMath} from \"./utils/Decimal.sol\";\nimport {DecimalERC20} from \"./utils/DecimalERC20.sol\";\nimport {IMinter} from \"./interface/IMinter.sol\";\nimport {BlockContext} from \"./utils/BlockContext.sol\";\nimport {IInflationMonitor} from \"./interface/IInflationMonitor.sol\";\n\n// record the extra inflation due to the unexpected loss\ncontract InflationMonitor is IInflationMonitor, IfnxFiOwnableUpgrade, BlockContext, DecimalERC20 {\n    using Decimal for Decimal.decimal;\n    using SafeMath for uint256;\n\n    /**\n     * @notice Stores timestamp and cumulative amount of minted token\n     */\n    struct MintedTokenEntry {\n        uint256 timestamp;\n        Decimal.decimal cumulativeAmount;\n    }\n\n    uint256 public constant MINT_THRESHOLD_PERIOD = 1 weeks;\n\n    //**********************************************************//\n    //    Can not change the order of below state variables     //\n    //**********************************************************//\n\n    // An array of token mint timestamp and cumulative amount\n    MintedTokenEntry[] private mintedTokenHistory;\n\n    /**\n     * @notice in percentage, if (minted token in a week) / (total supply) is less than `shutdownThreshold`,\n     * it's ready to shutdown\n     */\n    Decimal.decimal public shutdownThreshold;\n\n    IMinter private minter;\n\n    //**********************************************************//\n    //    Can not change the order of above state variables     //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    function initialize(IMinter _minter) public initializer {\n        __Ownable_init();\n\n        minter = _minter;\n        shutdownThreshold = Decimal.one().divScalar(10);\n    }\n\n    function setShutdownThreshold(Decimal.decimal memory _shutdownThreshold) public onlyOwner {\n        shutdownThreshold = _shutdownThreshold;\n    }\n\n    function appendMintedTokenHistory(Decimal.decimal calldata _amount) external override {\n        require(_msgSender() == address(minter), \"!minter\");\n        Decimal.decimal memory cumulativeAmount;\n        uint256 len = mintedTokenHistory.length;\n        if (len == 0) {\n            cumulativeAmount = _amount;\n        } else {\n            cumulativeAmount = mintedTokenHistory[len - 1].cumulativeAmount.addD(_amount);\n        }\n        mintedTokenHistory.push(\n            MintedTokenEntry({timestamp: _blockTimestamp(), cumulativeAmount: cumulativeAmount})\n        );\n    }\n\n    function mintedAmountDuringMintThresholdPeriod() public view returns (Decimal.decimal memory) {\n        uint256 len = mintedTokenHistory.length;\n        if (len == 0) {\n            return Decimal.zero();\n        }\n\n        uint256 durationSinceLastMinted = _blockTimestamp().sub(\n            mintedTokenHistory[len - 1].timestamp\n        );\n        if (durationSinceLastMinted > MINT_THRESHOLD_PERIOD) {\n            return Decimal.zero();\n        }\n\n        Decimal.decimal memory minted;\n        for (uint256 i = len - 1; i > 0; i--) {\n            Decimal.decimal memory amount = mintedTokenHistory[i].cumulativeAmount.subD(\n                mintedTokenHistory[i - 1].cumulativeAmount\n            );\n            minted = minted.addD(amount);\n\n            durationSinceLastMinted += mintedTokenHistory[i].timestamp.sub(\n                mintedTokenHistory[i - 1].timestamp\n            );\n            if (durationSinceLastMinted > MINT_THRESHOLD_PERIOD) {\n                break;\n            }\n        }\n        return minted;\n    }\n\n    function isOverMintThreshold() external view override returns (bool) {\n        if (shutdownThreshold.toUint() == 0) {\n            return false;\n        }\n        Decimal.decimal memory totalSupply = _totalSupply(minter.getIfnxToken());\n        Decimal.decimal memory minted = mintedAmountDuringMintThresholdPeriod();\n        return minted.divD(totalSupply).cmp(shutdownThreshold) >= 0;\n    }\n}\n"
    },
    "contracts/mock/InflationMonitorFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../InflationMonitor.sol\";\n\ncontract InflationMonitorFake is InflationMonitor {\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    function mock_getCurrentTimestamp() public view returns (uint256) {\n        return _blockTimestamp();\n    }\n\n    // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n}\n"
    },
    "contracts/mock/mocks/ExchangeWrapperMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { IExchangeWrapper, Decimal, IERC20 } from \"../../interface/IExchangeWrapper.sol\";\nimport { DecimalERC20 } from \"../../utils/DecimalERC20.sol\";\n\ncontract ExchangeWrapperMock is IExchangeWrapper, DecimalERC20 {\n    using Decimal for Decimal.decimal;\n\n    Decimal.decimal private exchangeRatio = Decimal.zero();\n    Decimal.decimal private spotPrice = Decimal.zero();\n    bool bException = false;\n\n    function mockSetSwapRatio(Decimal.decimal memory _ratio) public {\n        exchangeRatio = _ratio;\n    }\n\n    function mockSpotPrice(Decimal.decimal memory _price) public {\n        spotPrice = _price;\n    }\n\n    function mockSetException() public {\n        bException = true;\n    }\n\n    function swapInput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata inputTokenSold,\n        Decimal.decimal calldata,\n        Decimal.decimal calldata\n    ) external override returns (Decimal.decimal memory) {\n        if (bException) {\n            revert();\n        }\n        _transferFrom(inputToken, msg.sender, address(this), inputTokenSold);\n        _transfer(outputToken, msg.sender, inputTokenSold.divD(exchangeRatio));\n        return inputTokenSold.divD(exchangeRatio);\n    }\n\n    function swapOutput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata outputTokenBought,\n        Decimal.decimal calldata,\n        Decimal.decimal calldata\n    ) external override returns (Decimal.decimal memory) {\n        if (bException) {\n            revert();\n        }\n        _transferFrom(inputToken, msg.sender, address(this), outputTokenBought.mulD(exchangeRatio));\n        _transfer(outputToken, msg.sender, outputTokenBought);\n        return outputTokenBought.mulD(exchangeRatio);\n    }\n\n    function getInputPrice(\n        IERC20,\n        IERC20,\n        Decimal.decimal calldata inputTokenSold\n    ) external view override returns (Decimal.decimal memory) {\n        return inputTokenSold.divD(exchangeRatio);\n    }\n\n    function getOutputPrice(\n        IERC20,\n        IERC20,\n        Decimal.decimal calldata outputTokenBought\n    ) external view override returns (Decimal.decimal memory) {\n        return outputTokenBought.mulD(exchangeRatio);\n    }\n\n    function getSpotPrice(IERC20, IERC20) external view override returns (Decimal.decimal memory) {\n        return spotPrice;\n    }\n}\n"
    },
    "contracts/exchangeWrapper/ExchangeWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IfnxFiOwnableUpgrade} from \"../utils/IfnxFiOwnableUpgrade.sol\";\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {IJoeRouter02} from \"./traderjoe/IJoeRouter02.sol\";\nimport {IExchangeWrapper, Decimal} from \"../interface/IExchangeWrapper.sol\";\nimport {DecimalERC20} from \"../utils/DecimalERC20.sol\";\nimport {Decimal, SafeMath} from \"../utils/Decimal.sol\";\n\n// USDC/USDT decimal 6\ncontract ExchangeWrapper is IfnxFiOwnableUpgrade, IExchangeWrapper, DecimalERC20 {\n    using Decimal for Decimal.decimal;\n    using SafeMath for *;\n\n    // default max price slippage is 20% of spot price. 12e17 = (1 + 20%) e18\n    uint256 private constant DEFAULT_MAX_PRICE_SLIPPAGE = 12e17;\n\n    //\n    // EVENTS\n    //\n    event ExchangeSwap(uint256 ifnxTokenAmount, uint256 usdtAmount);\n    // for debug purpose in the future\n    event TraderJoeSwap(uint256 inAmount, uint256 out);\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n    IJoeRouter02 public joeRouter;\n    IERC20 private ifnxToken;\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n\n    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n    function initialize(address _joeRouter, address _ifnxToken) external initializer {\n        __Ownable_init();\n\n        ifnxToken = IERC20(_ifnxToken);\n        setJoeRouter(_joeRouter);\n    }\n\n    function swapInput(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal calldata _inputTokenSold,\n        Decimal.decimal calldata _minOutputTokenBought,\n        Decimal.decimal calldata _maxPrice\n    ) external override returns (Decimal.decimal memory) {\n        return\n            implSwapInput(\n                _inputToken,\n                _outputToken,\n                _inputTokenSold,\n                _minOutputTokenBought,\n                _maxPrice\n            );\n    }\n\n    function swapOutput(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal calldata _outputTokenBought,\n        Decimal.decimal calldata _maxInputTokeSold,\n        Decimal.decimal calldata _maxPrice\n    ) external override returns (Decimal.decimal memory) {\n        return\n            implSwapOutput(\n                _inputToken,\n                _outputToken,\n                _outputTokenBought,\n                _maxInputTokeSold,\n                _maxPrice\n            );\n    }\n\n    function getInputPrice(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal calldata _inputTokenSold\n    ) external view override returns (Decimal.decimal memory) {\n        Decimal.decimal memory spotPrice = implGetSpotPrice(_inputToken, _outputToken);\n        return _inputTokenSold.mulD(spotPrice);\n    }\n\n    function getOutputPrice(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal calldata _outputTokenBought\n    ) external view override returns (Decimal.decimal memory) {\n        Decimal.decimal memory spotPrice = implGetSpotPrice(_inputToken, _outputToken);\n        return _outputTokenBought.divD(spotPrice);\n    }\n\n    function getSpotPrice(IERC20 _inputToken, IERC20 _outputToken)\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return implGetSpotPrice(_inputToken, _outputToken);\n    }\n\n    function approve(\n        IERC20 _token,\n        address _to,\n        Decimal.decimal memory _amount\n    ) public onlyOwner {\n        _approve(_token, _to, _amount);\n    }\n\n    function setJoeRouter(address _joeRouter) public onlyOwner {\n        joeRouter = IJoeRouter02(_joeRouter);\n    }\n\n    //\n    // INTERNALS\n    //\n\n    function implSwapInput(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal memory _inputTokenSold,\n        Decimal.decimal memory _minOutputTokenBought,\n        Decimal.decimal memory _maxPrice\n    ) internal returns (Decimal.decimal memory outTokenAmount) {\n        address sender = _msgSender();\n\n        //___0. transfer input token to exchangeWrapper\n        _transferFrom(_inputToken, sender, address(this), _inputTokenSold);\n\n        //___1. swap\n        outTokenAmount = traderJoeSwapIn(\n            _inputToken,\n            _outputToken,\n            _inputTokenSold,\n            _minOutputTokenBought,\n            _maxPrice\n        );\n\n        //___2. transfer back to sender\n        _transfer(_outputToken, sender, outTokenAmount);\n    }\n\n    function implSwapOutput(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal memory _outputTokenBought,\n        Decimal.decimal memory _maxInputTokenSold,\n        Decimal.decimal memory _maxPrice\n    ) internal returns (Decimal.decimal memory) {\n        address sender = _msgSender();\n\n        //___1. calc how much input tokens needed by given outTokenBought,\n        Decimal.decimal memory expectedTokenInAmount = calcTraderJoeInGivenOut(\n            address(_inputToken),\n            address(_outputToken),\n            _outputTokenBought\n        );\n        require(\n            _maxInputTokenSold.cmp(expectedTokenInAmount) >= 0,\n            \"max input amount less than expected\"\n        );\n\n        //___2 transfer input tokens to exchangeWrapper\n        _transferFrom(_inputToken, sender, address(this), expectedTokenInAmount);\n\n        //___3. swap\n        Decimal.decimal memory requiredInAmount = traderJoeSwapOut(\n            _inputToken,\n            _outputToken,\n            _outputTokenBought,\n            _maxInputTokenSold,\n            _maxPrice\n        );\n\n        emit ExchangeSwap(requiredInAmount.toUint(), _outputTokenBought.toUint());\n\n        //___4. transfer back to sender\n        _transfer(_outputToken, sender, _outputTokenBought);\n\n        return requiredInAmount;\n    }\n\n    function traderJoeSwapIn(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal memory _inputTokenSold,\n        Decimal.decimal memory _minOutputTokenBought,\n        Decimal.decimal memory _maxPrice\n    ) internal returns (Decimal.decimal memory) {\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = address(_inputToken);\n        swapPath[1] = address(_outputToken);\n\n        // if max price is 0, set to (DEFAULT_MAX_PRICE_SLIPPAGE x spot price)\n        if (_maxPrice.toUint() == 0) {\n            uint256 spotPrice = getTraderJoeSpotPrice(swapPath);\n            _maxPrice = Decimal.decimal(spotPrice).mulD(\n                Decimal.decimal(DEFAULT_MAX_PRICE_SLIPPAGE)\n            );\n        }\n\n        _approve(IERC20(_inputToken), address(joeRouter), _inputTokenSold);\n\n        uint256 tokenSold = _toUint(_inputToken, _inputTokenSold);\n\n        // swap\n\n        // Max price check before swap\n        uint256 spotPriceBefore = getTraderJoeSpotPrice(swapPath);\n        require(spotPriceBefore <= _maxPrice.toUint(), \"ERR_BAD_LIMIT_PRICE\");\n\n        uint256[] memory outputAmounts = joeRouter.swapExactTokensForTokens(\n            tokenSold,\n            _toUint(_outputToken, _minOutputTokenBought),\n            swapPath,\n            address(this),\n            block.timestamp\n        );\n        uint256 outAmountInSelfDecimals = outputAmounts[1];\n\n        // Max price check after swap\n        uint256 spotPriceAfter = getTraderJoeSpotPrice(swapPath);\n        require(spotPriceAfter <= _maxPrice.toUint(), \"ERR_BAD_LIMIT_PRICE\");\n\n        require(outAmountInSelfDecimals > 0, \"Balancer exchange error\");\n        emit TraderJoeSwap(tokenSold, outAmountInSelfDecimals);\n\n        return _toDecimal(_outputToken, outAmountInSelfDecimals);\n    }\n\n    function traderJoeSwapOut(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        Decimal.decimal memory _outputTokenBought,\n        Decimal.decimal memory _maxInputTokenSold,\n        Decimal.decimal memory _maxPrice\n    ) internal returns (Decimal.decimal memory tokenAmountIn) {\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = address(_inputToken);\n        swapPath[1] = address(_outputToken);\n\n        // if max price is 0, set to (DEFAULT_MAX_PRICE_SLIPPAGE x spot price)\n        if (_maxPrice.toUint() == 0) {\n            uint256 spotPrice = getTraderJoeSpotPrice(swapPath);\n            _maxPrice = Decimal.decimal(spotPrice).mulD(\n                Decimal.decimal(DEFAULT_MAX_PRICE_SLIPPAGE)\n            );\n        }\n\n        _approve(IERC20(_inputToken), address(joeRouter), _maxInputTokenSold);\n\n        // swap\n        uint256 tokenBought = _toUint(_outputToken, _outputTokenBought);\n        uint256 maxTokenSold = _toUint(_inputToken, _maxInputTokenSold);\n\n        // Max price check before swap\n        uint256 spotPriceBefore = getTraderJoeSpotPrice(swapPath);\n        require(spotPriceBefore <= _maxPrice.toUint(), \"ERR_BAD_LIMIT_PRICE\");\n\n        uint256[] memory inputAmounts = joeRouter.swapTokensForExactTokens(\n            tokenBought,\n            maxTokenSold,\n            swapPath,\n            address(this),\n            block.timestamp\n        );\n        uint256 inAmountInSelfDecimals = inputAmounts[1];\n\n        // Max price check after swap\n        uint256 spotPriceAfter = getTraderJoeSpotPrice(swapPath);\n        require(spotPriceAfter <= _maxPrice.toUint(), \"ERR_BAD_LIMIT_PRICE\");\n\n        require(inAmountInSelfDecimals > 0, \"Balancer exchange error\");\n        emit TraderJoeSwap(inAmountInSelfDecimals, tokenBought);\n\n        return _toDecimal(_inputToken, inAmountInSelfDecimals);\n    }\n\n    function getTraderJoeSpotPrice(address[] memory path)\n        internal\n        view\n        returns (uint256 spotPrice)\n    {\n        uint256[] memory amounts = joeRouter.getAmountsOut(1, path);\n        spotPrice = amounts[1];\n    }\n\n    function calcTraderJoeInGivenOut(\n        address _inToken,\n        address _outToken,\n        Decimal.decimal memory _givenOutAmount\n    ) internal view returns (Decimal.decimal memory) {\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = _inToken;\n        swapPath[1] = _outToken;\n\n        uint256 givenOut = _toUint(IERC20(_outToken), _givenOutAmount);\n\n        uint256[] memory amounts = joeRouter.getAmountsIn(givenOut, swapPath);\n\n        uint256 expectedTokenInAmount = amounts[1];\n        return _toDecimal(IERC20(_inToken), expectedTokenInAmount);\n    }\n\n    function implGetSpotPrice(IERC20 _inputToken, IERC20 _outputToken)\n        internal\n        view\n        returns (Decimal.decimal memory)\n    {\n        if (_inputToken == _outputToken) return Decimal.one();\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = address(_inputToken);\n        swapPath[1] = address(_outputToken);\n\n        uint256 spotPrice = getTraderJoeSpotPrice(swapPath);\n\n        // // the amount returned from getSpotPrice includes decimals difference between tokens.\n        // // for example, input/output token pair, USDC(8 decimals)/PERP(18 decimals) and 2 USDC buy 1 PERP,\n        // // it returns 0.5e-10*e18, in the other direction(PERP/USDC), it returns 2e10*e18\n        Decimal.decimal memory price = Decimal.decimal(spotPrice);\n\n        uint256 decimalsOfInput = _getTokenDecimals(address(_inputToken));\n        uint256 decimalsOfOutput = _getTokenDecimals(address(_outputToken));\n        if (decimalsOfInput < decimalsOfOutput) {\n            price = _toDecimal(_inputToken, price.toUint());\n        } else if (decimalsOfInput > decimalsOfOutput) {\n            price = Decimal.decimal(_toUint(_outputToken, price));\n        }\n\n        return price;\n    }\n}\n"
    },
    "contracts/exchangeWrapper/traderjoe/IJoeRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\nimport {IJoeRouter01} from \"./IJoeRouter01.sol\";\n\ninterface IJoeRouter02 is IJoeRouter01 {\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountAVAX);\n\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/exchangeWrapper/traderjoe/IJoeRouter01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IJoeRouter01 {\n    function factory() external pure returns (address);\n\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityAVAX(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountAVAX,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAX(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/mock/DecimalERC20Fake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\nimport {DecimalERC20} from \"../utils/DecimalERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\n\n// a testing purpose container contract which used DecimalERC20 library\ncontract DecimalERC20Fake is DecimalERC20 {\n    function transfer(\n        IERC20 _token,\n        address _receiver,\n        Decimal.decimal calldata _amount\n    ) external {\n        _transfer(_token, _receiver, _amount);\n    }\n\n    function transferFrom(\n        IERC20 _token,\n        address _sender,\n        address _receiver,\n        Decimal.decimal calldata _amount\n    ) external {\n        _transferFrom(_token, _sender, _receiver, _amount);\n    }\n\n    function approve(\n        IERC20 _token,\n        address _spender,\n        Decimal.decimal calldata _amount\n    ) external {\n        _approve(_token, _spender, _amount);\n    }\n\n    function allowance(\n        IERC20 _token,\n        address _owner,\n        address _spender\n    ) external view returns (Decimal.decimal memory) {\n        return _allowance(_token, _owner, _spender);\n    }\n\n    function balanceOf(IERC20 _token, address _owner)\n        external\n        view\n        returns (Decimal.decimal memory)\n    {\n        return _balanceOf(_token, _owner);\n    }\n}\n"
    },
    "contracts/mock/MixedDecimalFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/MixedDecimal.sol\";\n\ncontract MixedDecimalFake {\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    constructor() public {}\n\n    function fromDecimal(Decimal.decimal memory x)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = MixedDecimal.fromDecimal(x);\n    }\n\n    function toUint(SignedDecimal.signedDecimal memory x) public pure returns (uint256) {\n        return x.toUint();\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by Decimal.decimal\n    function mul(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.mulD(y);\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by a uint256\n    function mulScalar(SignedDecimal.signedDecimal memory x, uint256 y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.mulScalar(y);\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a Decimal.decimal\n    function div(SignedDecimal.signedDecimal memory x, Decimal.decimal memory y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.divD(y);\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a uint256\n    function divScalar(SignedDecimal.signedDecimal memory x, uint256 y)\n        public\n        pure\n        returns (SignedDecimal.signedDecimal memory z)\n    {\n        z = x.divScalar(y);\n    }\n}\n"
    },
    "contracts/AmmReader.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport { Amm } from \"./Amm.sol\";\nimport { Decimal } from \"./utils/MixedDecimal.sol\";\n\ncontract AmmReader {\n    using Decimal for Decimal.decimal;\n    struct AmmStates {\n        uint256 quoteAssetReserve;\n        uint256 baseAssetReserve;\n        uint256 tradeLimitRatio;\n        uint256 fundingPeriod;\n        string quoteAssetSymbol;\n        string baseAssetSymbol;\n        bytes32 priceFeedKey;\n        address priceFeed;\n    }\n\n    function getAmmStates(address _amm) external view returns (AmmStates memory) {\n        Amm amm = Amm(_amm);\n        (bool getSymbolSuccess, bytes memory quoteAssetSymbolData) =\n            address(amm.quoteAsset()).staticcall(abi.encodeWithSignature(\"symbol()\"));\n        (Decimal.decimal memory quoteAssetReserve, Decimal.decimal memory baseAssetReserve) = amm.getReserve();\n\n        bytes32 priceFeedKey = amm.priceFeedKey();\n        return\n            AmmStates({\n                quoteAssetReserve: quoteAssetReserve.toUint(),\n                baseAssetReserve: baseAssetReserve.toUint(),\n                tradeLimitRatio: amm.tradeLimitRatio(),\n                fundingPeriod: amm.fundingPeriod(),\n                priceFeed: address(amm.priceFeed()),\n                priceFeedKey: priceFeedKey,\n                quoteAssetSymbol: getSymbolSuccess ? abi.decode(quoteAssetSymbolData, (string)) : \"\",\n                baseAssetSymbol: bytes32ToString(priceFeedKey)\n            });\n    }\n\n    // TODO: move to library\n    function bytes32ToString(bytes32 _key) private pure returns (string memory) {\n        uint8 length;\n        while (length < 32 && _key[length] != 0) {\n            length++;\n        }\n        bytes memory bytesArray = new bytes(length);\n        for (uint256 i = 0; i < 32 && _key[i] != 0; i++) {\n            bytesArray[i] = _key[i];\n        }\n        return string(bytesArray);\n    }\n}\n"
    },
    "contracts/mock/StakingReserveFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../StakingReserve.sol\";\n\ncontract StakingReserveFake is StakingReserve {\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    function mock_getCurrentTimestamp() public view returns (uint256) {\n        return _blockTimestamp();\n    }\n\n    // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n}\n"
    },
    "contracts/mock/DecimalFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/Decimal.sol\";\n\ncontract DecimalFake {\n    using Decimal for Decimal.decimal;\n\n    constructor() public {}\n\n    /// @dev multiple two decimals\n    function mul(Decimal.decimal memory x, Decimal.decimal memory y)\n        public\n        pure\n        returns (Decimal.decimal memory z)\n    {\n        z = x.mulD(y);\n    }\n\n    /// @dev multiple a Decimal.decimal by a uint256\n    function mulScalar(Decimal.decimal memory x, uint256 y)\n        public\n        pure\n        returns (Decimal.decimal memory z)\n    {\n        z = x.mulScalar(y);\n    }\n\n    /// @dev divide two decimals\n    function div(Decimal.decimal memory x, Decimal.decimal memory y)\n        public\n        pure\n        returns (Decimal.decimal memory z)\n    {\n        z = x.divD(y);\n    }\n\n    /// @dev divide a Decimal.decimal by a uint256\n    function divScalar(Decimal.decimal memory x, uint256 y)\n        public\n        pure\n        returns (Decimal.decimal memory z)\n    {\n        z = x.divScalar(y);\n    }\n}\n"
    },
    "contracts/interface/IRewardsDistribution.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ninterface IRewardsDistribution {\n    function distributeRewards(Decimal.decimal calldata) external;\n}\n"
    },
    "contracts/mock/AmmFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../Amm.sol\";\n\ncontract AmmFake is Amm {\n    constructor(\n        uint256 _dcQuoteAssetReserve,\n        uint256 _dcBaseAssetReserve,\n        uint256 _dcTradeLimitRatio,\n        uint256 _fundingPeriod,\n        IPriceFeed _priceFeed,\n        bytes32 _priceFeedKey,\n        address _quoteAsset,\n        uint256 _fluctuation,\n        uint256 _tollRatio,\n        uint256 _spreadRatio\n    ) public {\n        Amm.initialize(\n            _dcQuoteAssetReserve,\n            _dcBaseAssetReserve,\n            _dcTradeLimitRatio,\n            _fundingPeriod,\n            _priceFeed,\n            _priceFeedKey,\n            _quoteAsset,\n            _fluctuation,\n            _tollRatio,\n            _spreadRatio\n        );\n    }\n\n    uint256 private timestamp = 1444004400;\n    uint256 private number = 10001;\n\n    function mock_setBlockTimestamp(uint256 _timestamp) public {\n        timestamp = _timestamp;\n    }\n\n    function mock_setBlockNumber(uint256 _number) public {\n        number = _number;\n    }\n\n    function mock_getCurrentTimestamp() public view returns (uint256) {\n        return _blockTimestamp();\n    }\n\n    function mock_getCurrentBlockNumber() public view returns (uint256) {\n        return _blockNumber();\n    }\n\n    // Override BlockContext here\n    function _blockTimestamp() internal view override returns (uint256) {\n        return timestamp;\n    }\n\n    function _blockNumber() internal view override returns (uint256) {\n        return number;\n    }\n\n    function getInputPriceWithReservesPublic(\n        Dir _dir,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) public view returns (Decimal.decimal memory) {\n        return\n            getInputPriceWithReserves(\n                _dir,\n                _quoteAssetAmount,\n                _quoteAssetPoolAmount,\n                _baseAssetPoolAmount\n            );\n    }\n\n    function getOutputPriceWithReservesPublic(\n        Dir _dir,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) public view returns (Decimal.decimal memory) {\n        return\n            getOutputPriceWithReserves(\n                _dir,\n                _baseAssetAmount,\n                _quoteAssetPoolAmount,\n                _baseAssetPoolAmount\n            );\n    }\n\n    function mockSetReserve(\n        Decimal.decimal memory _quoteReserve,\n        Decimal.decimal memory _baseReserve\n    ) public {\n        quoteAssetReserve = _quoteReserve;\n        baseAssetReserve = _baseReserve;\n    }\n}\n"
    },
    "contracts/mock/SelfServeRrpBeaconServerWhitelisterMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../API3/ISelfServeRrpBeaconServerWhitelister.sol\";\n\ncontract SelfServeRrpBeaconServerWhitelisterMock is ISelfServeRrpBeaconServerWhitelister {\n    address public server;\n    mapping(bytes32 => mapping(address => bool)) public whitelisted;\n\n    constructor() public {}\n\n    function setBeaconIdToExpirationTimestamp(bytes32 _beaconId, uint64 _expirationTimestamp)\n        external\n        override\n    {}\n\n    function setBeaconIdToIndefiniteWhitelistStatus(\n        bytes32 _beaconId,\n        bool _indefiniteWhitelistStatus\n    ) external override {}\n\n    function whitelistReader(bytes32 _beaconId, address _reader) external override {\n        whitelisted[_beaconId][_reader] = true;\n    }\n\n    function beaconIdToExpirationTimestamp(bytes32 _beaconId)\n        external\n        view\n        override\n        returns (uint64)\n    {\n        return 0;\n    }\n\n    function beaconIdToIndefiniteWhitelistStatus(bytes32 _beaconId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    function rrpBeaconServer() external view override returns (address) {\n        return server;\n    }\n\n    function mockSetRrpBeaconServer(address _server) external {\n        server = _server;\n    }\n}\n"
    },
    "contracts/API3/ISelfServeRrpBeaconServerWhitelister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <=0.9.0;\n\ninterface ISelfServeRrpBeaconServerWhitelister {\n    event SetBeaconIdToExpirationTimestamp(bytes32 indexed beaconId, uint64 expirationTimestamp);\n    event SetBeaconIdToIndefiniteWhitelistStatus(\n        bytes32 indexed beaconId,\n        bool indefiniteWhitelistStatus\n    );\n    event WhitelistedReader(\n        bytes32 indexed beaconId,\n        address indexed reader,\n        uint64 expirationTimestamp,\n        bool indefiniteWhitelistStatus\n    );\n\n    function setBeaconIdToExpirationTimestamp(bytes32 _beaconId, uint64 _expirationTimestamp)\n        external;\n\n    function setBeaconIdToIndefiniteWhitelistStatus(\n        bytes32 _beaconId,\n        bool _indefiniteWhitelistStatus\n    ) external;\n\n    function whitelistReader(bytes32 _beaconId, address _reader) external;\n\n    function beaconIdToExpirationTimestamp(bytes32 _beaconId) external view returns (uint64);\n\n    function beaconIdToIndefiniteWhitelistStatus(bytes32 _beaconId) external view returns (bool);\n\n    function rrpBeaconServer() external view returns (address);\n}\n"
    },
    "contracts/mock/RrpBeaconServerFake.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport \"../API3/IRrpBeaconServer.sol\";\n\ncontract RrpBeaconServerFake is IRrpBeaconServer {\n    int224 public value;\n    uint32 public timestamp;\n\n    constructor() public {}\n\n    function extendWhitelistExpiration(\n        bytes32 beaconId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external override {}\n\n    function setWhitelistExpiration(\n        bytes32 beaconId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external override {}\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        bool status\n    ) external override {}\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        address setter\n    ) external override {}\n\n    function setUpdatePermissionStatus(address updateRequester, bool status) external override {}\n\n    function requestBeaconUpdate(\n        bytes32 beaconId,\n        address requester,\n        address designatedWallet,\n        bytes calldata parameters\n    ) external override {}\n\n    function fulfill(bytes32 requestId, bytes calldata data) external override {}\n\n    function readBeacon(bytes32 beaconId) external view override returns (int224, uint32) {\n        return (value, timestamp);\n    }\n\n    function readerCanReadBeacon(bytes32 beaconId, address reader)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    function beaconIdToReaderToWhitelistStatus(bytes32 beaconId, address reader)\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {}\n\n    function beaconIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {}\n\n    function sponsorToUpdateRequesterToPermissionStatus(address sponsor, address updateRequester)\n        external\n        view\n        override\n        returns (bool permissionStatus)\n    {}\n\n    function deriveBeaconId(bytes32 templateId, bytes calldata parameters)\n        external\n        pure\n        override\n        returns (bytes32 beaconId)\n    {}\n\n    function mockSetValueAndTimestamp(int224 _value, uint32 _timestamp) external {\n        value = _value;\n        timestamp = _timestamp;\n    }\n}\n"
    },
    "contracts/API3/IRrpBeaconServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <=0.9.0;\n\ninterface IRrpBeaconServer {\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed beaconId,\n        address indexed reader,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed beaconId,\n        address indexed reader,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        bytes32 indexed beaconId,\n        address indexed reader,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        bytes32 indexed beaconId,\n        address indexed reader,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event SetUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed updateRequester,\n        bool status\n    );\n\n    event RequestedBeaconUpdate(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        bytes32 templateId,\n        address sponsorWallet,\n        bytes parameters\n    );\n\n    event UpdatedBeacon(\n        bytes32 indexed beaconId,\n        bytes32 requestId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    function extendWhitelistExpiration(\n        bytes32 beaconId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 beaconId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        address setter\n    ) external;\n\n    function setUpdatePermissionStatus(address updateRequester, bool status) external;\n\n    function requestBeaconUpdate(\n        bytes32 beaconId,\n        address requester,\n        address designatedWallet,\n        bytes calldata parameters\n    ) external;\n\n    function fulfill(bytes32 requestId, bytes calldata data) external;\n\n    function readBeacon(bytes32 beaconId) external view returns (int224 value, uint32 timestamp);\n\n    function readerCanReadBeacon(bytes32 beaconId, address reader) external view returns (bool);\n\n    function beaconIdToReaderToWhitelistStatus(bytes32 beaconId, address reader)\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function beaconIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 beaconId,\n        address reader,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function sponsorToUpdateRequesterToPermissionStatus(address sponsor, address updateRequester)\n        external\n        view\n        returns (bool permissionStatus);\n\n    function deriveBeaconId(bytes32 templateId, bytes calldata parameters)\n        external\n        pure\n        returns (bytes32 beaconId);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}